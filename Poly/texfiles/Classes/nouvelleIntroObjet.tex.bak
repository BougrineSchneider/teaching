\begin{savequote}[80mm]
- - Ah, voilà enfin le roi de la classe ! L’homme trop bien sapé, Abitbol ! Alors comme ça tu as été élu l’homme le plus classe du monde ! Laisse-moi rire ! Style le grand playboy des fonds marins, [...]

- [...] Mais c'est pas ça qu'on appelle la classe. Je te dis ça en qualité d'homme le plus classe du monde.\\

- Eh je t'arrête tout de suite. La classe, c’est d'être chic dans sa manière de s'habiller. Rien de tel que d'aller chez Azzedine Alaia même de s'acheter des sous-pulls chez Yohji Yamamoto !\\

- Excuse-moi de te dire ça mon pauvre José, mais tu confonds un peu tout. Tu fais un amalgame entre la coquetterie et la classe. Tu es fou. Tu dépenses tout ton argent dans les habits et accessoires de mode mais tu es ridicule. Enfin si ça te plait... C'est toi qui les portes. Mais moi, si tu veux mon opinion, ça fait un peu... has been.\\

\qauthor{La classe américaine, José et Georges Abitbol}
\end{savequote}

\chapter{Introduction \`a l'objet : les classes}

La complexité d'un code n'est pas linéaire avec sa taille : plus un projet est volumineux, plus l'ajout marginal de code s'avère complexe. Il devient rapidement
(au delà de quelques centaines de lignes de code) nécessaire d'architecturer le code pour en faciliter la lecture,
et donc la maintenance et le debuggage. Cette problématique est devenue centrale. En effet, depuis 30 ans la taille des projets a explosé : pour maintenir un projet, il faut donc penser son architecture pour l'organiser comme une synergie d'objets indépendants incarnant chacun un rôle/une fonctionnalité.\\

L'idée fondamentale, c'est d'avoir des entités logiques riches, le plus distinctes, réduites et découplées possible. Dans ce chapitre, nous introduisons ces entités logiques riches, appelées classes. En règle générale, une classe regroupe un ensemble de données et de méthodes. L'architecture générale d'une classe est de ne rendre disponible qu'une petite partie de ses fonctions (appelées méthodes) et données, celles réellement utiles de l'extérieur, et de cacher pour l'extérieur la majorité de son implémentation. Cette conception permet de découpler les différentes complexités d'un programme et de simplifier la lecture du code : pour comprendre comment utiliser une classe, il suffit de comprendre ce que font les méthodes "publiques" et non pas de comprendre tous les mécanismes sous-jacents.\\

La notion de classe est si centrale qu'on désigne souvent les langages qui permettent ce genre d'entités comme des langages "orientés objet". Jusqu'à présent, nous avions présenté nos programmes sous une forme procédurale, c'est à dire qu'une méthode main appelait d'autres fonctions qui à leur tour en appelaient des autres, ... A présent, nous créerons des objets, instances de types plus complexes, où chaque type représentera un ensemble de méthodes et de données formant une unité logique.\\

A titre illustratif, nous utiliserons dans tout ce chapitre l'exemple d'une classe accumulator dont la fonction sera de calculer la moyenne et la variance empirique de valeurs réelles.

\section{Déclaration des classes}

Commençons par déclarer une classe Accumulator. Cette classe contiendra plusieurs variables, appelées des \textit{champs}. Voici la déclaration de cette classe dans le fichier Accumulator.h correspondant :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

#include <string.h>

class Accumulator
{
public:
	int n;
	double xSum;
	double xSquareSum;
}; //ne pas oublier le ; ici !

#endif
\end{lstlisting}
\end{DDbox}

Les champs n, xSum et xSquareSum sont intrinsèques à la classe. Chaque instance, c'est à dire chaque exemplaire de la classe Accumulator possèdera ces attributs.\\

Une fois notre classe déclarée, nous pouvons alors déclarer des instances de ce type;
Nous déclarons/définissons donc un accumulator dans notre main de la manière suivante :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//main.cpp
#include "Accumulator.h"

void main()
{
	Accumulator acc;
}

\end{lstlisting}
\end{DDbox}

Nous pouvons écrire des méthodes reliées à la classe Accumulator. Pour celà, nous ajoutons dans la déclaration de
notre classe les prototypes des méthodes que nous souhaitons ajouter :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
    public:
    	int n;
    	double xSum;
    	double xSquareSum;

    	void Add(double);
};

#endif
\end{lstlisting}
\end{DDbox}

Pour définir la méthode correspondante, nous procédons comme précédemment, mais précédons le nom de la méthode du nom de la classe suivi de "::", afin de signifier au compilateur que la méthode est attachée à cette classe (nous parlons alors de \textit{fonction membre}).\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.cpp

#include "Accumulator.h"

void Accumulator::Add(double x)
{
	n++;
    xSum += x;
    xSquareSum += x*x;
}
\end{lstlisting}
\end{DDbox}

Lorsque nous souhaitons utiliser une méthode ou un champ d'une classe, la syntaxe que nous utiliserons sera
la suivante :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
instance.champ = ...
instance.Method()
\end{lstlisting}
\end{DDbox}

En reprenant le code précédent, nous souhaitons maintenant calculer la moyenne des 10 premiers entiers. \\

Nous adaptons donc notre fonction main :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void main()
{
    //construction of object acc
    Accumulator acc;

    //Initialisation of the object
    acc.n=0;
    acc.xSum =0;
    acc.xSumQuare=0;

    for (int i = 0 ; i < 10;i++)
    {
        acc.Add( (double) i);
    }

    double mean = acc.xSum / acc.n;
}
\end{lstlisting}
\end{DDbox}

\section{Initialisation et constructeurs}

\subsection{Une première méthode d'initialisation}

L'initialisation proposée dans la section précédente présente plusieurs inconvénients :\\

\begin{itemize}
\item elle est très verbeuse, puisqu'il faut une ligne de code par champ renseigné.
\item il est possible (facile même) d'oublier un champ, et d'avoir alors un champ non initialisé, ce qui posera très vraissemblablement
problème par la suite.
\item nous n'avons pas d'initialisation par défaut de certains champs.\\
\end{itemize}

Créons donc une méthode d'initialisation de notre classe Accumulator en ajoutant une méthode Initialize. Nous updatons d'abord le fichier header
par le prototype de cette méthode :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//User.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
public:
	int n;
	double xSum;
	double xSquareSum;

	void Add(double);
	void Initialize(int, double, double);
};

#endif
\end{lstlisting}
\end{DDbox}

De même, nous ajoutons le code suivant dans le fichier .cpp : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void Accumulator::Initialize(int nInit, double xSumInit, double xSquareInit)
{
	n = nInit;
	xSum = xSumInit;
	xSquareSum = xSquareInit;
}
\end{lstlisting}
\end{DDbox}

Il nous suffit alors de transformer notre main en :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void main()
{
    //construction of object acc
	Accumulator acc;

    //Initialisation of the object
	acc.Initialize(0,0,0);
	
    for (int i = 0 ; i < 10;i++)
    {
        acc.Add( (double) i);
    }

    double mean = acc.xSum / acc.n;
}
\end{lstlisting}
\end{DDbox}

\subsection{Constructeurs}

Nous avons r\'esolu une partie des
probl\`emes \'enum\'er\'es pr\'ec\'edemment et avons donc au final un type
\texttt{Accumulator}, avec des \emph{propri\'et\'es (champs ou fonctions membres)} bien d\'efinies. Cependant,
un problème persiste : il faut obligatoirement appeler la méthode \texttt{Initialize}. C'est assez
		in\'el\'egant, car naturellement on voudrait que notre
		instance \texttt{acc}, soit
		créée "compl\`etement" dès qu'elle est définie. Par
		exemple, au moyen d'un code ressemblant au listing ci-dessous :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
Accumulator acc(0,0,0);
/*Initialize serait alors appelée automatiquement*/
\end{lstlisting}\end{DDbox}

Pour obtenir ce r\'esultat en C++, il suffit de d\'eclarer des fonctions sp\'eciales,
appel\'ees \emph{constructeurs}. Le constructeur est une m\'ethode ayant comme nom le nom de l'objet, \emph{sans type de retour}. Ajoutons donc un constructeur dans notre classe, qui remplacera notre fonction Initialize :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
public:
	int n;
	double xSum;
	double xSquareSum;

	Accumulator(int, double, double); // constructor
	void Add(double);
	void Initialize(int, double, double);
};
#endif
\end{lstlisting}\end{DDbox}

et le constructeur est défini dans Accumulator.cpp de la même manière que l'était la méthode Initialize :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
Accumulator::Accumulator(int nInit, double xSumInit, double xSquareInit)
{
	n = nInit;
	xSum = xSumInit;
	xSquareSum = xSquareInit;
}
\end{lstlisting}\end{DDbox}

\textit{Notez que la définition du constructeur n'est précédée d'aucun type, même void}.\\

Notre main devient donc :

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void main()
{
	Accumulator acc(0,0,0);
	
    for (int i = 0 ; i < 10;i++)
    {
        acc.Add( (double) i);
    }

    double mean = acc.xSum / acc.n;
}
\end{lstlisting}\end{DDbox}

Notez que le code suivant ne compilera plus :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void main()
{
	Accumulator acc; //Does not work anymore since the constructor expects 3 arguments.
	acc.Initialize(0,0,0);

    for (int i = 0 ; i < 10;i++)
    {
        acc.Add( (double) i);
    }

    double mean = acc.xSum / acc.n;
}
\end{lstlisting}\end{DDbox}

En effet, nous avons donné un seul prototype pour le constructeur: celui ci prend nécessairement 3 arguments, il n'est donc plus possible de construire une instance sans les préciser. Nous pourrions vouloir modifier cette situation, puisque dans la majorité des cas, les trois paramètres seront 0, et il semble un peu verbeux de devoir les respécifier impérativement. Nous pourrions par exemple \textit{surcharger} le constructeur avec un autre prototype, c'est à dire ajouter un deuxième constructeur, de même nom, mais avec des arguments différents :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
public:
	int n;
	double xSum;
	double xSquareSum;

	Accumulator(int, double, double);
	Accumulator();
	~Accumulator(void);
	void Add(double);
	void Initialize(int, double, double);
};
#endif
\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}
\begin{lstlisting}
Accumulator::Accumulator(int nInit, double xSumInit, double xSquareInit)
{
	n = nInit;
	xSum = xSumInit;
	xSquareSum = xSquareInit;
}

Accumulator::Accumulator()
{
	n = 0;
	xSum = 0;
	xSquareSum = 0;
}
\end{lstlisting}\end{DDbox}

\subsection{liste d'initialisation}

A la construction d'une instance, il est possible de remplir les différents champs de la classe d'une manière différente, via la \textit{liste d'initialisation}. Cette technique consiste à intercaler dans la définition du constructeur entre son prototype et les accolades \{ et \} le nom de chaque champ, puis entre parenthèses la valeur qui doit lui être assignée. Ainsi, dans notre exemple précédent, celà reviendrait à :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
Accumulator::Accumulator(int nInit, double xSumInit, double xSquareInit) : n(nInit), xSum(xSumInit), xSquareSum(xSquareInit)
{
}
\end{lstlisting}\end{DDbox}

Si les deux formes d'initialisation amènent en règle générale au même résultat, ce n'est cependant pas toujours le cas. Vous ne pouvez pas vous tromper en utilisant la liste d'initialisation, dans le sens où celle-ci est plus précise et générale que l'initialisation dans le constructeur, mais elle peut sembler aussi plus verbeuse. A votre niveau, vous pouvez utiliser indiférremment l'un ou l'autre.

\subsection{Constructeur par défaut}

Lorsque vous ne spécifiez pas de constructeur dans une classe, Visual Studio en crée un implicitement, sans argument et sans logique interne. Ainsi, ne pas mettre de constructeur dans la classe Accumulator revient à écrire :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
public:
	int n;
	double xSum;
	double xSquareSum;

	Accumulator();
	void Add(double);
	void Initialize(int, double, double);
};
#endif
\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}
\begin{lstlisting}
Accumulator::Accumulator()
{
}
\end{lstlisting}\end{DDbox}

\subsection{Destructeur}

De la même manière qu'il existe une fonction spéciale pour construire des instances correctement initialisées, il existe une fonction spéciale, appelée destructeur, systématiquement appelée par l'environnement à la destruction de l'objet, par exemple quand son scope se termine. Pour les objets que nous avons considérés jusqu'à présent, le destructeur n'a besoin de rien faire de spécial. Comme pour le constructeur, il a un nom particulier : c'est le même que la classe, avec le symbole "$\sim$" en préfixe :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
public:
	int n;
	double xSum;
	double xSquareSum;

	Accumulator(int, double, double);
	Accumulator();
	~Accumulator(void); //Destructor
	void Add(double);
	void Initialize(int, double, double);
};

#endif
\end{lstlisting}\end{DDbox}

Et le fichier Accumulator.cpp est updaté avec la définition du destructeur : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
Accumulator::~Accumulator(void)
{
}
\end{lstlisting}\end{DDbox}

Nous reviendrons plus en détail dans les chapitres suivants quant à l'usage des destructeurs.

\section{Encapsulation}

\subsection{Notions de champs publics et champs privés}

Dans la déclaration de notre classe Accumulator, nous avons fait précédé la déclaration des champs et des fonctions membres par le mot clef \textit{public}. Par ce mot clef, nous rendons tous les champs et toutes les fonctions membres qui suivent ce mot clef accessibles "à l'extérieur de la classe". Ainsi, grâce à ce mot clef, nous avons pu dans la fonction main accéder directement au champ xSum par exemple : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//main.cpp
#include "Accumulator.h"

void main()
{
	Accumulator acc(0,0,0);

    for (int i = 0 ; i < 10;i++)
    {
        acc.Add( (double) i);
    }

    double mean = acc.xSum / acc.n;
}

\end{lstlisting}\end{DDbox}

Nous pourrions choisir de mettre les champs de cette classe en privé, en modifiant de manière adéquate le fichier header : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
private:
	int n;
	double xSum;
	double xSquareSum;

public:
	Accumulator(int, double, double);
	Accumulator();
	~Accumulator(void);
	void Add(double);
	void Initialize(int, double, double);
};

#endif
\end{lstlisting}\end{DDbox}

Lorsqu'un champ d'une classe est déclaré en privé, il n'est pas accessible en dehors des fonctions membres de la classe. Ainsi, le compilateur refusera de compiler les instructions suivantes : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//main.cpp
#include "Accumulator.h"

void main()
{
	Accumulator acc;
	acc.Add(1);

	double mean = acc.xSum / acc.n; //ERROR: private fields xSum and n cannot be accessed outside the class Accumulator
}
\end{lstlisting}\end{DDbox}

Comment dès lors calculer la moyenne ? Il suffit de créer une méthode publique qui puisse manipuler les champs privés et qui nous retourne publiquement cette valeur :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
double Accumulator::GetMean(void)
{
	return xSum / n;
}
\end{lstlisting}\end{DDbox}

Si cette méthode est publique, même si les champs xSum et n sont privés, il sera alors possible d'accéder à la moyenne, partout dans notre code. Ce faisant, nous avons contraint la manière dont un utilisateur peut accéder à la moyenne : sa seule solution est de passer par cette méthode publique, spécifiquement créée dans ce dessin. En architecture logicielle, le fait de contraindre un utilisateur dans sa manière d'utiliser un code est une excellente habitude, car c'est un moyen très efficace de l'empêcher de réimplémenter lui-même de la logique, et donc d'écrire du code qui pourrait se révéler défaillant ou difficile à maintenir. Au contraire, il faut s'efforcer que toute la logique relative à une classe se trouve implémentée par des méthodes de celle-ci, et que seuls les résultats de ces méthodes soient accessibles depuis l'extérieur de la classe.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//main.cpp
#include "Accumulator.h"

void main()
{
	Accumulator acc;
	acc.Add(1);

	double mean = acc.GetMean();
}
\end{lstlisting}\end{DDbox}

Par convention, les champs privés d'une classe sont préfixés par "\_". Nos fichiers header et source devenant alors : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
private:
	int _n;
	double _xSum;
	double _xSquareSum;

public:
	Accumulator(int, double, double);
	Accumulator();
	~Accumulator(void);
	void Add(double);

	double GetMean(void);
};

#endif
\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#include "Accumulator.h"

Accumulator::Accumulator(int nInit, double xSumInit, double xSquareInit)
{
	_n = nInit;
	_xSum = xSumInit;
	_xSquareSum = xSquareInit;
}

Accumulator::Accumulator()
{
	_n = 0;
	_xSum = 0;
	_xSquareSum = 0;
}

Accumulator::~Accumulator(void)
{
}

void Accumulator::Add(double x)
{
	_n++;
    _xSum += x;
    _xSquareSum += x*x;
}

double Accumulator::GetMean(void)
{
	return _xSum / _n;
}

\end{lstlisting}\end{DDbox}

\subsection{Accesseurs}

Pour accéder à des champs privés depuis l'extérieur d'une classe, il est possible de définir des accesseurs, c'est à dire des méthodes publiques accédant en lecture ou en écriture à un champ privé spécifique. Par convention, un accesseur en lecture à un champ est préfixé par Get, et un accesseur en écriture est prefixé par Set. Ainsi, nous pouvons par exemple déclarer un accesseur en lecture pour notre champ privé \_n, afin de connaître combien d'exemples ont été fournis à notre accumulator :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//in Accumulator.cpp :
int Accumulator::GetN(void)
{
	return _n;
}
\end{lstlisting}\end{DDbox}

\subsection{Philosophie de l'encapsulation}

Pourquoi donc utiliser des accesseurs alors qu'il serait plus rapide de déclarer le champ public et de pouvoir le lire et le modifier plus facilement ? C'est le principe même de l'encapsulation, ébauché ci-dessus. Les champs d'une classe servent en règle générale à décrire un état interne de la classe, qui ne doit pas être accessible de l'extérieur.\\

Au contraire, il faut considérer qu'une classe bien conçue fournit un minimum de fonctions publiques, qui correspondent aux fonctionnalités de la classe. Les méthodes privées, ainsi que les champs(privés), servent d'intermédiaires aux méthodes publiques pour découper la logique générale exposée par ces dernières en des quantums de logique plus petits.\\

En adoptant un tel design, nous minimisons pour l'utilisateur de la classe Accumulator la quantité de compréhension qu'il doit posséder de cette classe pour l'utiliser. Sans connaître son implémentation interne, un utilisateur qui comprend ce que font les méthodes publiques d'une classe est capable de l'utiliser. Ce design permet ainsi de découpler de manière importante les dépendances sémantiques entre classes, et ainsi d'abstraire le code.\\

\section{Méthodes et variables statiques}
\subsection{Champs statiques}

Supposons que nous ayions plusieurs instances de la classe Accumulator. Nous souhaiterions savoir combien d'exemples au total ont été présentés à une instance quelconque de cette classe. Dans le cas où nous avons seulement deux exemplaires de la classe Accumulator, nous pourrions procéder de cette manière :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
	void main()
	{
		Accumulator acc1;
	    acc1.Add(1);
        acc1.Add(7);

        Accumulator acc2;
	    acc2.Add(4);

        int n1 = acc1.GetN();
        int n2 = acc2.GetN();

        int n = n1+n2;
	}
\end{lstlisting}\end{DDbox}

Cependant, lorsque nous ne connaissons pas le nombre exacts d'accumulateurs créés ni leur nom, la tâche devient plus difficile. Comment donc procéder?

\begin{itemize}
		
	\item Nous pourrions utiliser une variable globale que nous incr\'ementerions dans
		le constructeur de \texttt{User} et d\'ecr\'ementerions dans le
		destructeur. Cette solution est peu \'el\'egante car il s'agit
		fondamentalement d'une \emph{propri\'et\'e de la classe}. Par
		ailleurs,  si nous voulions compter d'autres classes que
		\classname{User}, nous nous retrouverions rapidement avec un grand
		nombre	de variables, ce qui finirait par \^etre peu pratique \`a
		manipuler. En règle générale, \textbf{il faut absolument s'interdire l'utilisation de variables globales.}\\
		
	\item Nous pourrions utiliser une des fonctionnalit\'es du C++ : la
		\emph{variable de classe} ou \emph{variable statique}.
		
\end{itemize}

Une variable statique est tout simplement un attribut d'une classe, mais qui
\emph{n'est pas propre \`a une instance}. Au contraire, il est partag\'e par
toutes les instances d'une m\^eme classe. Voici le prototype de la déclaration d'un membre statique:\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
static int userCount;
\end{lstlisting}\end{DDbox}

Utilisons donc un champ static entier pour compter combien d'instances ont été initialisées au total. La déclaration de notre classe Accumulator devient alors :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
private:
	int _n;
	double _xSum;
	double _xSquareSum;
	static int nTotal;

public:
	Accumulator(int, double, double);
	Accumulator();
	~Accumulator(void);
	void Add(double);

	double GetMean(void);
	int GetN(void);
};

#endif
\end{lstlisting}\end{DDbox}

Et nous modifions la méthode Add pour que celle-ci incrémente également notre champ static :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void Accumulator::Add(double x)
{
	_n++;
    _xSum += x;
    _xSquareSum += x*x;
	nTotal++;
}
\end{lstlisting}\end{DDbox}

Ainsi, chaque fois que nous appellerons la méthode Add, que ce soit sur l'instance acc1 ou l'instance acc2, ou encore sur une autre instance, le champ static (et donc partagé) nTotal sera incrémenté.\\

Comment devons-nous initialiser ce champ ? Puisque le champ static existe indépendemment des instances de la classe Accumulator, ce champ préexiste en fait même à la première instance de la classe Accumulator qui pourra être créée. Il faut donc l'initialiser en dehors d'un constructeur. La syntaxe pour initialiser un champ static d'une classe est la suivante (à ajouter dans le fichier Accumulator.cpp, en dehors de toute fonction):\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
int Accumulator::nTotal=0;
\end{lstlisting}\end{DDbox}


\warning L'initialisation des variables statiques peut poser problème. En effet, le compilateur agit "comme si" les variables
étaient toutes déclarées, puis elles sont ensuite définies dans l'ordre dans lequel le compilateur lit les définitions dans le fichier source.
Nous pouvons alors avoir des comportements étranges, comme en témoigne l'exemple suivant :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//A.h
#ifndef A_H
#define A_H

class A
{
	static int a;
	static int b;
};

#endif
\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//A.cpp

#include "A.h"

int A::a = b+1;
int A::b = a+1;

\end{lstlisting}\end{DDbox}

Les valeurs prises par les variables a et b sont respectivement 1 et 2, mais si nous modifions l'ordre dans lequel nous
affectons ces variables statiques, leurs valeurs sont inversées : a vaut 2 et b vaut 1 :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//A.cpp

#include "A.h"

int A::b = a+1;
int A::a = b+1;
\end{lstlisting}\end{DDbox}

\subsection{Méthodes statiques}

Nous voudrions maintenant instancier un accumulator à la condition qu'il n'en existe pas déjà un. Pour faire ceci, nous voulons tout d'abord ajouter un compteur qui va dénombrer le nombre d'instances de la classe Accumulator qui ont été créées. Nous ajoutons donc un autre champ entier statique "accumulatorInstancesCreated" dans le fichier header, et l'initialisons dans le fichier Accumulator.cpp.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
private:
	int _n;
	double _xSum;
	double _xSquareSum;
	static int nTotal;
	static int accumulatorInstancesCreated;

public:
	Accumulator(int, double, double);
	Accumulator();
	~Accumulator(void);
	void Add(double);

	double GetMean(void);
	int GetN(void);
};

#endif
\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#include "Accumulator.h"

Accumulator::Accumulator(int nInit, double xSumInit, double xSquareInit)
{
	_n = nInit;
	_xSum = xSumInit;
	_xSquareSum = xSquareInit;
	accumulatorInstancesCreated++;
}

Accumulator::Accumulator()
{
	_n = 0;
	_xSum = 0;
	_xSquareSum = 0;
	accumulatorInstancesCreated++;
}

Accumulator::~Accumulator(void)
{
}

void Accumulator::Add(double x)
{
	_n++;
    _xSum += x;
    _xSquareSum += x*x;
	nTotal++;
}

double Accumulator::GetMean(void)
{
	return _xSum / _n;
}

int Accumulator::GetN(void)
{
	return _n;
}

int Accumulator::nTotal=0;
int Accumulator::accumulatorInstancesCreated=0;
\end{lstlisting}\end{DDbox}

Comment maintenant tester si une instance a déjà été créée ? Puisque le champ static "accumulatorInstancesCreated" est privé, il est nécessaire de construire une méthode GetInstancesCount() renvoyant cette valeur. Cependant, si aucune instance n'a encore été créée, comment pourrions nous écrire instance.GetInstancesCount() ?\\

Il est maintenant nécessaire d'ajouter un concept, celui de fonction statique. Une fonction est dite statique, si son comportement ne dépend pas de l'état interne de l'instance appelante, autrement dit, si son résultat et ses effets pourraient être appelés sur n'importe quelle instance de la classe avec à chaque fois le même effet. Puisqu'une telle fonction n'a pas besoin d'une instance spécifique pour être appelée, elle est dite statique et est attachée à la classe plutôt qu'à une instance spécifique.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//Accumulator.h
#ifndef ACCUMULATOR_H
#define ACCUMULATOR_H

class Accumulator
{
private:
	int _n;
	double _xSum;
	double _xSquareSum;
	static int nTotal;
	static int accumulatorInstancesCreated;

public:
	Accumulator(int, double, double);
	Accumulator();
	~Accumulator(void);
	void Add(double);
	static int GetInstancesCreatedCount(void); //new static method just created

	double GetMean(void);
	int GetN(void);
};

#endif
\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}
\begin{lstlisting}
//In Accumulator.cpp :

int Accumulator::GetInstancesCreatedCount(void)
{
	return accumulatorInstancesCreated;
}
\end{lstlisting}\end{DDbox}

Les méthodes statiques publiques, tout comme les champs statiques publics, ne sont pas appelés via une instance mais directement via le nom de la classe suivi de ::. Ainsi, nous pouvons tester dans notre main par exemple s'il existe déjà une instance ou non :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void main()
{
    if (Accumulator::GetInstancesCreatedCount() >= 1)
    {
        //.....
    }
}
\end{lstlisting}\end{DDbox}

Remarque : une méthode statique n'a pas nécessairement besoin de champs statiques. C'est seulement une manière de signifier que son code est indépendant de l'instance appelante. Par exemple, nous pourrions concevoir une méthode statique Merge qui prendrait en argument deux instances de la classe Accumulator et qui en construirait une troisième. Cet exemple est laissé à titre d'exercice au lecteur.\\

Note : Il est tout indiqué de déclarer les méthodes comme statiques dès que possible. Lorsque nous écrivons "du code mathématique", nos méthodes sont contenues dans des classes mais ne dépendent bien souvent
d'aucun des champs de la classe. C'est le cas idéal pour utiliser des méthodes statiques.
%
%Supposons que nous souhaitions \`a pr\'esent rajouter une m\'ethode qui apparie deux utilisateurs, plutôt que
%de le faire directement comme précédemment. Nous pourrions rajouter une m\'ethode simple, de la forme suivante:
%
%\begin{lstlisting}
%	void User::BringTogether(User* first, User* second)
%	{
%		(*first).pPartner = second;
%		(*second).pPartner = first;
%		(*first).isSingle = false;
%		(*second).isSingle = false;
%	}
%\end{lstlisting}\end{DDbox}
%
%Il existe une syntaxe plus succinte lorsque nous manipulons des champs d'un pointeur p sur une instance :
%
%\begin{lstlisting}
%(*p).field = ... // equals :
%p->field = ...
%\end{lstlisting}\end{DDbox}
%
%Nous utiliserons par la suite cette deuxième syntaxe, notre méthode devenant :
%
%\begin{lstlisting}
%	void User::BringTogether(User* first, User* second)
%	{
%		first->pPartner = second;
%		second->pPartner = first;
%		first->isSingle = false;
%		second->isSingle = false;
%	}
%\end{lstlisting}\end{DDbox}
%
%Pour l'instant, il faudrait utiliser une instance pour appeler cette méthode. Nous pourrions par exemple
%faire un appel de la sorte :
%
%\begin{lstlisting}
%	void main()
%	{
%		User loana(...);
%		User jeanEdouard(...);
%		loana.BringTogether(&loana, &jeanEdouard);
%\end{lstlisting}\end{DDbox}
%
%Ici, la méthode que nous avons créée est indépendante de l'instance utilisée pour appeler la méthode.
%Ceci implique que quel que soit l'instance de la classe que nous utiliserions pour appeler cette méthode, nous obtiendrions le même
%résultat. Nous pourrions obtenir le même résultat par un appel de la sorte :
%
%\begin{lstlisting}
%	void main()
%	{
%		User loana(...);
%		User jeanEdouard(...);
%		User kenza(...);
%		kenza.BringTogether(&loana, &jeanEdouard);
%	}
%\end{lstlisting}\end{DDbox}
%
%Cette méthode devrait donc pouvoir être appelée indépendamment d'une instance de la classe User.
%Mieux : en spécifiant que la méthode ne nécessite pas d'instance spécifique, nous informons le relecteur que cette méthode
%n'aura aucun effet sur l'instance qui appelle la méthode. La méthode ne pourra donc avoir d'effet que sur
%ses arguments. Cette restriction permet de simplifier énormément la complexité des intéractions possibles entre
%méthodes d'une classe. Il faut donc toujours spécifier quand c'est possible qu'une méthode a cette propriété,
%dite statique. Nous adaptons donc notre méthode de la sorte dans le header :
%
%\begin{lstlisting}
%void static BringTogether(User*, User*);
%\end{lstlisting}\end{DDbox}
%
%Et nous ne changeons rien dans le fichier source, où le mot clef static ne doit pas être répété.
%
%Nous updatons alors notre fonction main et vérifions qu'à la fin de l'exécution du main, loana possède bien un pointeur
%vers jeanEdouard, et réciproquement.
%
%


\subsection{constructeur statique}

En C++, il n'existe pas de constructeur statique comme le constructeur statique de C\# ou les statics blocs de Java.
Les constructeurs statiques peuvent être très utiles lorsque vous souhaitez effectuer une opération qui aura
toujours le même résultat quelle que soit l'instance créée. L'utilisation d'un constructeur statique peut
permettre de n'effectuer cette opération qu'une seule fois. Ceci n'est pas possible de cette manière en C++.

