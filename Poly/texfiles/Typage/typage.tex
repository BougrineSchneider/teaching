\begin{savequote}
"I spent a few weeks... trying to sort out the terminology of "strongly typed," "statically typed," "safe," etc., and found it amazingly difficult.... The usage of these terms is so various as to render them almost useless.", Benjamin C. Pierce, in \textit{Types and Programming Languages} \end{savequote}

\chapter{Variables et Typage}
\label{chapter:variableEttypage}

\textit{Vous êtes familiers avec les mots clefs int, short, long, double et float, et avec la base 2 ? sautez ce chapitre en première lecture.}\\

\textit{Remarque préliminaire} : L'alphabet d'un ordinateur est limité aux signes 0 et 1, ce qui correspond à une porte électronique ouverte ou fermée, et cet état est représenté par 1 bit. Avec un ensemble de n bits, nous pouvons former $2^n$ combinaisons différentes, et donc stocker au plus $2^n$ valeurs différentes. Toutes les variables ont besoin de plusieurs bits pour définir leur valeur, et l'unité de référence pour la taille mémoire est l'octet (byte en anglais), c'est à dire un paquet de 8 bits consécutifs \footnote{On prendra donc bien garde à ne pas confondre bit et byte (=8 bits). Certains providers internet abusent d'ailleurs de cette confusion en affichant les débits garantis en terme de Mbits/secs, c'est pourquoi vous avez une connection de 100 Mbits, mais que vous ne téléchargez pas à plus de quelques Mo/sec ...}. Dans ce chapitre, nous faisons un bref rappel des systèmes de base et introduisons les différents types primitifs du C++.

\section{Représentation décimale}

La représentation des nombres que nous utilisons dans la vie de tous les jours est une représentation en base 10\footnote{Même si nous utilisons également des vieilles bases sexagécimales (60) d'origine babylonienne pour compter les minutes ou les secondes.}. C'est à dire qu'une dizaine est consituée de dix unités, qu'une centaine est constituée de dix dizaines, etc. Les bases utilisées en informatique sont principalement des bases binaires et hexadécimales (16), ceci étant lié à l'alphabet réduit à 2 caractères (0 ou 1).

\section{Représentation en base 2}

La représentation en mémoire des entiers (mais aussi des décimaux) va utiliser le principe de l'écriture en base 2. Sur tous les processeurs PC \footnote{et depuis récemment sous les machines Apple, le lecteur souhaitant développer sous des machines Mac un peu vieilles et utiliser des lectures disque est très vivement invité à s'enquérir du principe de Little et Big Endian.}, le bit le plus à gauche est utilisé comme bit de poids faible, et correspond selon sa valeur à 0 ou 1 ($2^0$). Pour le bit à sa droite, celui-ci correspond à la valeur 0 ou 2 ($2^1$), celui d'encore à droite à la valeur 0 ou 4 ($2^2$).

Quelques exemples :

\begin{align*}
10110 => 1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 => 13\\
011 => 0 * 2^0 + 1 * 2^1 + 1 *2^2 => 6
\end{align*}

\section{les nombres négatifs}

Comment représenter un nombre négatif ?  Comme il n'y a que deux possibilités pour un nombre (positif ou négatif), le signe d'un nombre peut être représenté sur un bit. Par convention, le bit de gauche d'un ensemble de bits est le bit de signe : sa valeur (0 ou 1) détermine le signe du nombre stocké dans les bits suivants. Celà diminue donc d'une unité le nombre de bits disponibles pour stocker le nombre lui-même. Lorsque l'on travaille uniquement avec des nombres positifs, il est possible de signifier à la machine que nous voulons faire l'économie du bit de signe pour pouvoir travailler sur des valeurs potentiellement plus grandes. Nous reviendrons sur ce point en dessous.

\section{les entiers}

Il existe en C++ 6 types d'entiers différents, qui se répartissent en deux catégories, les entiers signés et les entiers non-signés. Les entiers non signés, qui ont renoncé au bit de signe, peuvent donc prendre deux fois plus de valeurs que leurs analogues signés.\\

\begin{itemize}
\item Les \keyword{short} stockent un entier sur 2 octets, ils prennent des valeurs entre -32768 et +32767
\item Les \keyword{long} stockent un entier sur 4 octets, ils prennent des valeurs entre -2147843648 et +2147843647
\item Les \keyword{int} n'ont pas une taille définie par la spec du langage. Ils ont sur la plupart des compilateurs/machines une taille de 4 octets, et ont donc le même comportement que les long, mais ce n'est pas systématique.
\item Les \keyword{ushort} ou \keyword{unsigned short} stockent un entier sur 2 octets, ils prennent des valeurs entre 0 et +$2^{16} - 1$
\item Les \keyword{ulong} ou \keyword{unsigned long} stockent un entier sur 4 octets, ils prennent des valeurs entre 0 et +$2^{32} - 1$
\item Les \keyword{uint} ou \keyword{unsigned int} là encore, celà dépend des compilateurs, mais en règle générale, même cas que les unsigned long\\
\end{itemize}

Voici deux exemples de déclarations d'entiers.\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
unsigned int currentIndex;
int matchingCount;
\end{lstlisting}\end{DDbox}

Comme nous l'avons expliqué, signer ou non un entier a des cons\'equences sur
l'intervalle des valeurs qu'il peut prendre; ces intervalles sont
pr\'ecis\'es dans le tableau \ref{tab:bornessignes}\footnote{Les bornes pour les \keyword{int} ne sont valables que pour les architectures 32 bits.}.\\

\begin{table}
	\centering
	\begin{tabular}{c| c| c }
		Type & Minimum & Maximum \\
		\hline
		\keyword{unsigned int} & 0 & $2^{32}-1$ \\
		\keyword{int} & $-2^{31}$  & $2^{31}-1$ \\
		\hline
		\keyword{unsigned short} & 0 & $2^{16}-1$ \\
		\keyword{short} & $-2^{15}$  & $2^{15}-1$ \\
        \hline
		\keyword{unsigned long} & 0 & $2^{32}-1$ \\
		\keyword{long} & $-2^{31}$  & $2^{31}-1$ \\
		\hline
		\keyword{unsigned char} & 0 & $255$ \\
		\keyword{char} & $-128$  & $127$ \\
	\end{tabular}
	\caption{Bornes des diff\'erents types}
	\label{tab:bornessignes}
\end{table}

Que se passe-t-il lorsque l'on ajoute un à une variable entière qui contient la valeur maximale?
Un tel phénomène est appelé Integer Overflow. Dans le cas d'entiers signés, le résultat est imprévisible. Dans le cas d'entiers non signés, le résultat est réduit modulo une puissance de 2. C'est parfois drôle \footnote{ca donne des jolis Kill-Screen http://en.wikipedia.org/wiki/Pac-Man\#Split-screen}, ca donne parfois l'occasion de faire des bandes dessinées \footnote{http://xkcd.com/571/}, mais ca donne des bugs très pénibles à isoler, et qui peuvent se révéler catastrophique (ca peut même crasher une Ariane 5 \footnote{http://www.astrosurf.com/luxorion/astronautique-accident-ariane-v501.htm}).

\begin{habitudes}[Typage des entiers]
Nous invitons le lecteur à prendre l'habitude de ne travailler uniquement qu'avec des int, mais c'est un parti pris qui ne fait pas l'unanimité. Ceci peut se révéler problématique dans certains cas, notamment puisque la taille des int est laissée à la discrétion du compilateur et qu'un même programme compilé sur une même machine mais avec deux compilateurs différents pourra avoir des comportements différents. Cependant, l'utilisation des int est en règle générale très suffisante. La vraie raison qui nous porte à faire cette proposition est la simplicité de votre code. Utiliser des short ou des long, c'est attirer l'attention de votre relecteur sur le fait que vous vous êtes passés des int, et c'est implicitement suggérer que ce changement est nécessaire à l'endroit où vous l'avez fait. Un bon code se doit d'être simple et banal aux points les plus simples, et n'attirer l'attention du lecteur que lorsque ceci est nécessaire.
\end{habitudes}

\section{Les réels}

Les nombres décimaux sont stockés autrement que les nombres entiers. Ils sont dits à virgule flottante. Les nombres à virgule flottante sont des nombres dans lesquels la position de la virgule en tant que séparateur entre partie entière et partie décimale n'est pas figée. La grandeur d'un tel nombre est donnée par un exposant de 10 adéquat. Par exemple, le nombre 27,6 peut être écrit sous les 3 formes :

\begin{align*}
2,76 * 10^1\\
0,276 * 10^2\\
276 * 10 ^{-1}
\end{align*}

Dans la mémoire de la machine, un nombre réel est décomposé en un signe (+ ou -), en un exposant (ex : $10^1$), et une mantisse (ex : 2,76).
Comme nous avons plusieurs types pour distinguer les entiers selon les plages de valeurs que nous anticipons, nous avons également plusieurs types différents pour stocker un réel.\\

\begin{itemize}
\item Les \keyword{float} : sur 4 octets, mantisse sur 23 bits, exposant sur 8 bits, signe sur 1 bit. Le float garantit une précision d'au moins 6 chiffres après la virgule.
\item Les \keyword{double} : sur 8 octets, mantisse sur 52 bits, exposant sur 11 bits, signe sur 1 bit. Le double garantit une précision d'au moins 15 chiffres après la virgule.
\item Les \keyword{long double} : sur 10 octets, mantisse sur 64 bits, exposant sur 15 bits. Le long double garantit une précision d'au moins 17 chiffres après la virgule.
\end{itemize}

\begin{habitudes}[Typage des réels]
Là aussi, nous prenons le parti de vous conseiller d'utiliser uniquement des double. L'utilisation de float suggère à votre lecteur que vous êtes en train de faire des économies sur la mémoire pour faire des optimisations fines. En règle générale, étant donnés la taille des RAMs actuelles et le salaire horaire des bons développeurs, il vaut mieux avoir un programme un peu moins optimisé et éviter des bugs atroces qui peuvent coûter des semaines à détecter et fixer car vous avez voulu économiser un peu d'espace mémoire \footnote{Repensez à la fusée Ariane !}.
\end{habitudes}

\section{Déclaration des variables}

Il est crucial de comprendre la différence entre définition et déclaration. Nous renvoyons le lecteur au chapitre sur la compilation/interprétation si ce pas n'est pas encore clair\footnote{Nous vous avions bien dit qu'il fallait lire ce chapitre jusqu'à l'avoir compris !}.\\

Lorsque nous souhaitons d\'eclarer une variable, nous le faisons de la mani\`ere suivante :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
TypeDeLaVariable NomDeLaVariable;
\end{lstlisting}\end{DDbox}

La d\'eclaration peut \^etre effectu\'ee n'importe o\`u dans le code. Cependant, l'endroit où elle est déclarée est extrêmement important, puisqu'il définit le scope de la variable, c'est à dire sa portée, et pourra parfois empêcher la compilation. Nous reviendrons sur ce point lorsque nous aurons introduit les fonctions.\\

\begin{habitudes}[D\'eclaration des variables]
	Une bonne habitude est de d\'eclarer les variables le plus tard possible dans le code, c'est à dire de minimiser leur scope, afin d'am\'eliorer la lisibilit\'e et d'aider le compilateur dans ses optimisations\footnote{Il y a des contre-exemples bien sûr, mais celà dépasse le cadre de ce cours}.
\end{habitudes}

\begin{habitudes}[Nom des variables]
Toutes vos variables, comme tous vos fichiers, vos méthodes et vos commentaires doivent être nommés en anglais.
\begin{enumerate}
\item L'anglais est souvent plus compact. Pouvoir exprimer une idée en moins de lettre est extrêmement appréciable puisque nous voulons limiter la taille des noms des variables.
\item Certains concepts n'ont pas de traduction adéquate et répandue dans notre langue.
\item Vous serez très probablement amenés à travailler en équipe, régulièrement avec des gens non-francophones. Imaginez-vous devoir lire du code écrit et commenté en russe...\\
\end{enumerate}
\end{habitudes}

\begin{habitudes}[Nom des variables (2)]
Trouvez des noms courts, expressifs, spécifiques et non-provoquants (On est jamais à l'abri d'un bug qui soulève un retour windows en expliquant que l'instance z de la classe fuckstring n'a pas été instanciée, devant un client/n+1/examinateur...). Une exception : pour coder une fonction mathématique, ces conseils sont différents, préférez des noms de variables très courts à des noms expressifs, du type x, y, z, dx...
\end{habitudes}

Le listing suivant présente quelques exemples de déclaration de variables.\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
double threshold;
long   y;
int    length;
short  minValue;
float  mean;
char   firstLetter;
bool   isLocked;
\end{lstlisting}\end{DDbox}

\begin{table}
    \begin{tabular}{l l l l l}
    Type & Description &  Java & VBA \\
    \hline
    int  & Entier &   Integer & Integer \\
    double & Decimal double pr\'ecision  & Double & Double \\
    char & caract\`ere  & Char & char
    \end{tabular}
    \caption{Types de variables}
    \label{table:variableTypes}
\end{table}


\warning Il est important de noter que les noms des variables sont sensibles à la casse (case sensitive)\footnote{C'est-\`a-dire \`a la distinction entre majuscules et minuscules}. En d'autres termes, cela signifie que \varname{Variable1} et \varname{variable1} d\'esignent deux variables diff\'erentes. \textbf{Nous attirons votre attention sur cette propriété, qui sera source dans vos premiers programmes des trois quarts des erreurs de compilation que vous rencontrerez.}

\begin{habitudes}[Usage des majuscules]

Par convention,
\begin{itemize}
\item les variables commencent par une minuscule.
\item les fonctions commencent par une majuscule.
\item les classes commencent par une majuscule.
\item les constantes commencent par une majuscule.
\item les constantes définies par un \#define sont entièrement en majuscules.
\item lorsqu'un nom est la concaténation de plusieurs mots, la première lettre de chaque mot en dehors du premier prend une majuscule (ex: PerfectRedWidget).
\end{itemize}

Ces règles permettent de distinguer d'un seul coup d'oeil variables, classes et méthodes et sont indispensables\footnote{Nous nous acharnerons sur vous en TD si vous ne les respectez pas}. Elles permettent aussi de pouvoir recourir au type de syntaxe suivant, dans lequel le premier mot désigne le type et le deuxième mot désigne le nom de l'instance :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
Widget widget;
\end{lstlisting}\end{DDbox}

\end{habitudes}

\section{Les booléens}

Les variables de type \keyword{booléen} contiennent un booléen, c'est à dire une des deux valeurs suivantes : \textit{true} ou \textit{false}. Par convention, la valeur false correspond à 0, la valeur true correspond à 1. Un booléen pourrait donc être stocké sur un unique bit. Cependant, puisque tous les autres types ont besoin de plusieurs octets, il aurait été malavisé de n'utiliser qu'un bit pour les booléens, puisque ceci aurait introduit des décalages. Les booléens sont donc stockés sur un octet entier.

\section{Les caractères}

Il y a malheureusement plusieurs standards différents dans l'encodage des caractères\footnote{c.f. par exemple http://www.joelonsoftware.com/articles/Unicode.html}, tout comme il y a plusieurs types de clavier et plusieurs alphabets. C'est pourquoi vous récupérez parfois des mails avec des caractères étranges quand vous êtes sur des OS différents. Sur un octet, nous pouvons stocker 256 caractères différents. Un des standards les plus utilisés est le standard américain, ASCII. La variable caractère est désignée par le mot clef char, mais sauf cas de force majeur, utilisez plutôt des chaines de caractères représentées (string) que des tableaux de char.

\section{Types définis par l'utilisateur}

La déclaration/définition/instanciation de variables d'un type non primitif (c'est à dire défini par vous-même) s'effectue de la même manière.
Par exemple :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
Identifier identifier = myInstance.GetId();
\end{lstlisting}\end{DDbox}

Pour la définition de telles variables, nous approfondirons la question au chapitre dédié aux classes.\\

\section{Constantes et \'enum\'erations}
\subsection{Constantes}

R\'eguli\`erement lorsque nous \'ecrivons un programme, nous avons besoin de d\'efinir
des constantes, comme dans le listing \ref{lst:besoinconstante.cpp}.\\

\includecodecaption{besoinconstante.cpp}{N\'ecessit\'e d'une constante}

Dans le code précédent, rien n'interdit de
red\'efinir la valeur de cette ``constante'' au cours du programme. Il est
possible de rem\'edier \`a ce probl\`eme au moyen du mot cl\'e \keyword{const}, qui indique qu'une variable est constante, et ne peut \^etre modifi\'ee.\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
	const type instanceName = value;
\end{lstlisting}\end{DDbox}

Le listing \ref{lst:besoinconstante.cpp} devient alors :\\

\includecodecaption{besoinconstanteresolu.cpp}{N\'ecessit\'e d'une constante}

\subsection{Enum\'erations}

Nous pouvons \'egalement avoir besoin d'une liste de constantes mais li\'ees entre elles. Consid\'erons le code du listing \ref{lst:besoinenum.cpp}.\\

\includecodecaption{besoinenum.cpp}{Une s\'erie de constantes}

Ce code pr\'esente plusieurs probl\`emes :

\begin{itemize}
		
	\item Il est possible de passer une taille en dehors des valeurs de la liste de constantes. Par ailleurs, rien ne garantit que c'est bien une taille que nous allons passer;
	\item Si nous voulons rajouter de nouvelles tailles, il faut g\'erer soi-m\^eme l'attribution de nouvelles valeurs (4, 5, 6, etc.).\\
		
\end{itemize}

Le langage C++ fournit une m\'ethode automatique pour r\'esoudre ce probl\`eme, appellée \'enum\'eration. Nous d\'eclarons une \'enum\'eration de la mani\`ere suivante :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
	enum NomEnumeration
	{
		premierElement,
		deuxiemeElement,
		troisiemeElement
		...
	};
\end{lstlisting}\end{DDbox}

La num\'erotation\footnote{Ce n'est d'ailleurs pas forc\'ement 1, 2, 3, etc.} est automatique. En l'occurrence, notre enum\'eration s'\'ecrirait :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
	enum Size
	{
		Small,
		Medium,
		Big
	}
\end{lstlisting}\end{DDbox}

Le listing \ref{lst:besoinenum.cpp} devient alors:\\

\includecodecaption{besoinenumresolu.cpp}{Emploi d'une \'enum\'eration}

L'emploi d'une \'enum\'eration a donc r\'esolu nos probl\`emes :

\begin{itemize}

	\item Un mécanisme garantit que c'est bien une valeur valable qui sera passée en argument de la fonction f
	\item Nous pouvons rajouter de nouvelles valeurs sans nous pr\'eoccuper de la
		num\'erotation;
	\item Le code obtenu est nettement plus lisible.
		
\end{itemize}

\section{Le typage du C++}

Le C++ est un langage typ\'e de mani\`ere statique. Cela signifie que les variables doivent \^etre d\'eclar\'ees et leur types explicit\'es, à la différence par exemple du python où une variable peut contenir successivement un entier puis une chaîne de caractère ou un double. Le compromis qui se cache derrière ce choix est un compromis souplesse / performance. Devoir déterminer à l'exécution le type d'une variable plutôt que de l'avoir déterminé statiquement a un certain coût. Les types n'existent en C++ qu'à la compilation, c'est à dire qu'à l'execution il n'est plus possible de récupérer le type d'un objet; cette limitation ne se retrouve pas dans des langages plus récents comme le C\#.\footnote{En C\#, on peut par exemple récupérer le type d'un objet à l'exécution, parcourir l'ensemble des types chargés en mémoire, sélectionner les types qui héritent de telle classe et qui possèdent un constructeur vide, les instancier, etc.}.
