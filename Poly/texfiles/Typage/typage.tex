\begin{savequote}
"I spent a few weeks... trying to sort out the terminology of "strongly typed," "statically typed," "safe," etc., and found it amazingly difficult.... The usage of these terms is so various as to render them almost useless.", Benjamin C. Pierce, in \textit{Types and Programming Languages} \end{savequote}

\chapter{Variables et Typage}
\label{chapter:variableEttypage}

\textit{Vous êtes familiers avec les mots clefs int, short, long, double et float, et avec la base 2 ? sautez ce chapitre en première lecture.}\\

\textit{Remarque préliminaire} : L'alphabet d'un ordinateur est limité aux signes 0 et 1, ce qui correspond à une porte électronique ouverte ou fermée, et cet état est représenté par un bit. Avec un ensemble de n bits, nous pouvons former $2^n$ combinaisons différentes, et donc stocker au plus $2^n$ valeurs différentes. Toutes les variables ont besoin de plusieurs bits pour définir leur valeur, et l'unité de référence pour la taille mémoire est l'octet (byte en anglais), c'est à dire un paquet de 8 bits consécutifs \footnote{On prendra donc bien garde à ne pas confondre bit et byte (=8 bits). Certains providers internet abusent d'ailleurs de cette confusion en affichant les débits garantis en terme de Mbits/secs, c'est pourquoi vous avez une connection de 100 Mbits, mais que vous ne téléchargez pas à plus de quelques Mo/sec ...}. Dans ce chapitre, nous faisons un bref rappel des systèmes de base et introduisons les différents types primitifs du C++.

\section{Représentation décimale}

La représentation des nombres que nous utilisons dans la vie de tous les jours est une représentation en base 10\footnote{Même si nous utilisons également des vieilles bases sexagécimales (60) d'origine babylonienne pour compter les minutes ou les secondes.}. C'est à dire qu'une dizaine est consituée de dix unités, qu'une centaine est constituée de dix dizaines, etc. Les bases utilisées en informatique sont principalement des bases binaires et hexadécimales (16), ceci étant lié à l'alphabet réduit à 2 caractères (0 ou 1).

\section{Représentation en base 2}

La représentation en mémoire des entiers (mais aussi des décimaux) va utiliser le principe de l'écriture en base 2. Sur tous les processeurs PC \footnote{et depuis récemment sous les machines Apple, le lecteur souhaitant développer sous des machines Mac un peu vieilles et utiliser des lectures disque est très vivement invité à s'enquérir du principe de Little et Big Endian.}, le bit le plus à gauche est utilisé comme bit de poids faible, et correspond selon sa valeur à 0 ou 1 ($2^0$). Pour le bit à sa droite, celui-ci correspond à la valeur 0 ou 2 ($2^1$), celui d'encore à droite à la valeur 0 ou 4 ($2^2$).

Quelques exemples :

\begin{align*}
10110 => 1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 => 13\\
011 => 0 * 2^0 + 1 * 2^1 + 1 *2^2 => 6
\end{align*}

\section{les nombres négatifs}

Comment représenter un nombre négatif ?  Comme il n'y a que deux possibilités pour un nombre (positif ou négatif), le signe d'un nombre peut être représenté sur un bit. Par convention, le bit de gauche d'un ensemble de bits est le bit de signe : sa valeur (0 ou 1) détermine le signe du nombre stocké dans les bits suivants. Celà diminue donc d'une unité le nombre de bits disponibles pour stocker le nombre lui-même. Lorsque l'on travaille uniquement avec des nombres positifs, il est possible de signifier à la machine que nous voulons faire l'économie du bit de signe pour pouvoir travailler sur des valeurs potentiellement plus grandes. Nous revenons sur ce point au paragraphe suivant.

\section{les entiers}

Il existe en C++ 6 types d'entiers différents, qui se répartissent en deux catégories, les entiers signés et les entiers non-signés. Les entiers non signés, qui ont renoncé au bit de signe, peuvent donc prendre deux fois plus de valeurs que leurs analogues signés.\\

\begin{itemize}
\item Les \keyword{short} stockent un entier sur 2 octets, ils prennent des valeurs entre -32768 et +32767
\item Les \keyword{long} stockent un entier sur 4 octets, ils prennent des valeurs entre -2147843648 et +2147843647
\item Les \keyword{int} n'ont pas une taille définie par la spec du langage. Ils ont sur la plupart des compilateurs/machines une taille de 4 octets, et ont donc le même comportement que les long, mais ce n'est pas systématique.
\item Les \keyword{ushort} ou \keyword{unsigned short} stockent un entier sur 2 octets, ils prennent des valeurs entre 0 et +$2^{16} - 1$
\item Les \keyword{ulong} ou \keyword{unsigned long} stockent un entier sur 4 octets, ils prennent des valeurs entre 0 et +$2^{32} - 1$
\item Les \keyword{uint} ou \keyword{unsigned int} là encore, celà dépend des compilateurs, mais en règle générale, même cas que les unsigned long\\
\end{itemize}

Voici deux exemples de déclarations d'entiers.\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
unsigned int currentIndex;
int matchingCount;
\end{lstlisting}\end{DDbox}

Comme nous l'avons expliqué, signer ou non un entier a des cons\'equences sur
l'intervalle des valeurs qu'il peut prendre; ces intervalles sont
pr\'ecis\'es dans le tableau \ref{tab:bornessignes}\footnote{Les bornes pour les \keyword{int} ne sont valables que pour les architectures 32 bits.}.\\

\begin{table}
	\centering
	\begin{tabular}{c| c| c }
		Type & Minimum & Maximum \\
		\hline
		\keyword{unsigned int} & 0 & $2^{32}-1$ \\
		\keyword{int} & $-2^{31}$  & $2^{31}-1$ \\
		\hline
		\keyword{unsigned short} & 0 & $2^{16}-1$ \\
		\keyword{short} & $-2^{15}$  & $2^{15}-1$ \\
        \hline
		\keyword{unsigned long} & 0 & $2^{32}-1$ \\
		\keyword{long} & $-2^{31}$  & $2^{31}-1$ \\
		\hline
		\keyword{unsigned char} & 0 & $255$ \\
		\keyword{char} & $-128$  & $127$ \\
	\end{tabular}
	\caption{Bornes des diff\'erents types}
	\label{tab:bornessignes}
\end{table}

Que se passe-t-il lorsque l'on ajoute un à une variable entière qui contient la valeur maximale?
Un tel phénomène est appelé Integer Overflow. Dans le cas d'entiers signés, le résultat est imprévisible. Dans le cas d'entiers non signés, le résultat est réduit modulo une puissance de 2. Les effets sont parfois amusants \footnote{cela donne par exemple des jolis Kill-Screen http://en.wikipedia.org/wiki/Pac-Man\#Split-screen}, c'est aussi parfois l'occasion de faire des bandes dessinées \footnote{http://xkcd.com/571/}, mais les overflows peuvent amener des bugs très pénibles à isoler, et qui peuvent se révéler catastrophique (une Ariane 5 s'est écrasée à cause d'un overflow principalement \footnote{http://www.astrosurf.com/luxorion/astronautique-accident-ariane-v501.htm}).

\begin{habitudes}[Typage des entiers]
Nous invitons le lecteur à prendre l'habitude de ne travailler uniquement qu'avec des int, mais c'est un parti pris qui ne fait pas l'unanimité. Ceci peut se révéler problématique dans certains cas, notamment puisque la taille des int est laissée à la discrétion du compilateur et qu'un même programme compilé sur une même machine mais avec deux compilateurs différents pourra avoir des comportements différents. Cependant, l'utilisation des int est en règle générale très suffisante. La vraie raison qui nous porte à faire cette proposition est la simplicité de votre code. Utiliser des short ou des long, c'est attirer l'attention de votre relecteur sur le fait que vous vous êtes passés des int, et c'est implicitement suggérer que ce changement est nécessaire à l'endroit où vous l'avez fait. Un bon code se doit d'être simple et banal aux points les plus simples, et n'attirer l'attention du lecteur que lorsque ceci est nécessaire.
\end{habitudes}

\section{Les réels}

Les nombres réels sont stockés autrement que les nombres entiers. Ils sont dits à virgule flottante. Les nombres à virgule flottante sont des nombres dans lesquels la position de la virgule en tant que séparateur entre partie entière et partie décimale n'est pas figée. La grandeur d'un tel nombre est donnée par un exposant de 10 adéquat. Par exemple, le nombre 27,6 peut être écrit sous les 3 formes :

\begin{align*}
2,76 * 10^1\\
0,276 * 10^2\\
276 * 10 ^{-1}
\end{align*}

Dans la mémoire de la machine, un nombre réel est décomposé en un signe (+ ou -), en un exposant (ex : $10^1$), et une mantisse (ex : 2,76).
Comme nous avons plusieurs types pour distinguer les entiers selon les plages de valeurs que nous anticipons, nous avons également plusieurs types différents pour stocker un réel.\\

\begin{itemize}
\item Les \keyword{float} : sur 4 octets, mantisse sur 23 bits, exposant sur 8 bits, signe sur 1 bit. Le float garantit une précision d'au moins 6 chiffres après la virgule.
\item Les \keyword{double} : sur 8 octets, mantisse sur 52 bits, exposant sur 11 bits, signe sur 1 bit. Le double garantit une précision d'au moins 15 chiffres après la virgule.
\item Les \keyword{long double} : sur 10 octets, mantisse sur 64 bits, exposant sur 15 bits. Le long double garantit une précision d'au moins 17 chiffres après la virgule.
\end{itemize}

\begin{habitudes}[Typage des réels]
Pareillement, nous vous conseillons d'utiliser uniquement des double. L'utilisation de float suggère à votre lecteur que vous êtes en train de faire des économies sur la mémoire pour faire des optimisations fines. En règle générale, étant donnés la taille des RAMs actuelles et le salaire horaire des bons développeurs, il vaut mieux avoir un programme un peu moins optimisé en emprunte mémoire (\textit{Memory footprint}) et éviter des bugs atroces qui peuvent coûter des semaines à détecter et fixer\footnote{Repensez à la fusée Ariane !}.
\end{habitudes}

\section{Déclaration des variables}

Il est crucial de comprendre la différence entre définition et déclaration. Nous renvoyons le lecteur au chapitre sur la compilation/interprétation si ce pas n'est pas encore clair\footnote{Nous vous avions bien dit qu'il fallait lire ce chapitre jusqu'à l'avoir compris !}.\\

Lorsque nous souhaitons d\'eclarer une variable, nous le faisons de la mani\`ere suivante :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
TypeDeLaVariable NomDeLaVariable;
\end{lstlisting}\end{DDbox}

La d\'eclaration peut \^etre effectu\'ee n'importe o\`u dans le code. Cependant, l'endroit où elle est déclarée est extrêmement important, puisqu'il définit le scope de la variable, c'est à dire sa portée, et pourra parfois empêcher la compilation. Nous reviendrons sur ce point lorsque nous aurons introduit les fonctions.\\

\begin{habitudes}[D\'eclaration des variables]
	Une bonne habitude est de d\'eclarer les variables le plus tard possible dans le code, c'est à dire de minimiser leur scope, afin d'am\'eliorer la lisibilit\'e et d'aider le compilateur dans ses optimisations\footnote{Il y a des contre-exemples bien sûr, mais celà dépasse le cadre de ce cours}.
\end{habitudes}

\begin{habitudes}[Nom des variables]
Toutes vos variables, comme tous vos fichiers, vos méthodes et vos commentaires doivent être nommés en anglais.
\begin{enumerate}
\item L'anglais est souvent plus compact. Pouvoir exprimer une idée en moins de lettre est extrêmement appréciable puisque nous voulons limiter la taille des noms des variables.
\item Certains concepts n'ont pas de traduction adéquate et répandue dans notre langue.
\item Vous serez très probablement amenés à travailler en équipe, régulièrement avec des gens non-francophones. Imaginez-vous devoir lire du code écrit et commenté en russe...\\
\end{enumerate}
\end{habitudes}

\begin{habitudes}[Nom des variables (2)]
Trouvez des noms courts, expressifs, spécifiques et non-provoquants (On est jamais à l'abri d'un bug qui soulève un retour windows en expliquant que l'instance z de la classe fuckstring n'a pas été instanciée, devant un client/n+1/examinateur...). Une exception : pour coder une fonction mathématique, ces conseils sont différents, préférez des noms de variables très courts à des noms expressifs, du type x, y, z, dx, etc.
\end{habitudes}

Le listing suivant présente quelques exemples de déclaration de variables.\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
double threshold;
long   y;
int    length;
short  minValue;
float  mean;
char   firstLetter;
bool   isLocked;
\end{lstlisting}\end{DDbox}

\begin{table}
    \begin{tabular}{l l l l l}
    Type & Description &  Java & VBA \\
    \hline
    int  & Entier &   Integer & Integer \\
    double & Decimal double pr\'ecision  & Double & Double \\
    char & caract\`ere  & Char & char
    \end{tabular}
    \caption{Types de variables}
    \label{table:variableTypes}
\end{table}


\warning Il est important de noter que les noms des variables sont sensibles à la casse (case sensitive)\footnote{C'est-\`a-dire \`a la distinction entre majuscules et minuscules.}. En d'autres termes, cela signifie que \varname{Variable1} et \varname{variable1} d\'esignent deux variables diff\'erentes. \textbf{Nous attirons votre attention sur cette propriété, qui sera source dans vos premiers programmes des trois quarts des erreurs de compilation que vous rencontrerez.}

\begin{habitudes}[Usage des majuscules]

Par convention,
\begin{itemize}
\item les variables commencent par une minuscule.
\item les fonctions commencent par une majuscule.
\item les classes commencent par une majuscule.
\item les constantes commencent par une majuscule.
\item les constantes définies par un \#define sont entièrement en majuscules.
\item lorsqu'un nom est la concaténation de plusieurs mots, la première lettre de chaque mot en dehors du premier prend une majuscule (ex: PerfectRedWidget).
\end{itemize}

Ces règles permettent de distinguer d'un seul coup d'oeil variables, classes et méthodes et sont indispensables\footnote{Nous nous acharnerons sur vous en TD si vous ne les respectez pas.}. Elles permettent aussi de pouvoir recourir au type de syntaxe suivant, dans lequel le premier mot désigne le type et le deuxième mot désigne le nom de l'instance :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
Widget widget;
\end{lstlisting}\end{DDbox}

\end{habitudes}

\section{Les booléens}

Les variables de type \keyword{booléen} contiennent un booléen, c'est à dire une des deux valeurs suivantes : \textit{true} ou \textit{false}. Par convention, la valeur false correspond à 0, la valeur true correspond à 1. Un booléen pourrait donc être stocké sur un unique bit. Cependant, puisque tous les autres types ont besoin de plusieurs octets, il aurait été malavisé de n'utiliser qu'un bit pour les booléens, puisque ceci aurait introduit des décalages. Les booléens sont donc stockés sur un octet entier.

\section{Les caractères}

Il y a malheureusement plusieurs standards différents dans l'encodage des caractères\footnote{c.f. par exemple http://www.joelonsoftware.com/articles/Unicode.html}, tout comme il y a plusieurs types de clavier et plusieurs alphabets. C'est pourquoi vous récupérez parfois des mails avec des caractères étranges quand vous êtes sur des OS différents par exemple. Sur un octet, nous pouvons stocker 256 caractères différents. Un des standards les plus utilisés est le standard américain, ASCII. La variable caractère est désignée par le mot clef char, mais sauf cas de force majeur, utilisez plutôt des chaines de caractères représentées (string) que des tableaux de char.

\section{Types définis par l'utilisateur}

La déclaration/définition/instanciation de variables d'un type non primitif (c'est à dire défini par vous-même) s'effectue de la même manière.
Par exemple :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
Identifier identifier = myInstance.GetId();
\end{lstlisting}\end{DDbox}

Pour la définition de telles variables, nous approfondirons la question dans le chapitre dédié aux classes.\\

\section{Constantes et \'enum\'erations}
\subsection{Constantes}

R\'eguli\`erement lorsque nous \'ecrivons un programme, nous avons besoin de d\'efinir
des constantes, comme dans le listing \ref{lst:besoinconstante.cpp}.\\

\includecodecaption{besoinconstante.cpp}{N\'ecessit\'e d'une constante}

Dans le code précédent, rien n'interdit de
red\'efinir la valeur de cette ``constante'' au cours du programme. Il est
possible de rem\'edier \`a ce probl\`eme au moyen du mot cl\'e \keyword{const}, qui indique qu'une variable est constante, et ne peut \^etre modifi\'ee.\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
	const type instanceName = value;
\end{lstlisting}\end{DDbox}

Le listing \ref{lst:besoinconstante.cpp} devient alors :\\

\includecodecaption{besoinconstanteresolu.cpp}{N\'ecessit\'e d'une constante}

\subsection{Enum\'erations}

Nous pouvons \'egalement avoir besoin d'une liste de constantes mais li\'ees entre elles. Consid\'erons le code du listing \ref{lst:besoinenum.cpp}.\\

\includecodecaption{besoinenum.cpp}{Une s\'erie de constantes}

Ce code pr\'esente plusieurs probl\`emes :

\begin{itemize}
		
	\item Il est possible de passer une taille en dehors des valeurs de la liste de constantes. Par ailleurs, rien ne garantit que c'est bien une taille que nous allons passer;
	\item Si nous voulons rajouter de nouvelles tailles, il faut g\'erer soi-m\^eme l'attribution de nouvelles valeurs (4, 5, 6, etc.).\\
		
\end{itemize}

Le langage C++ fournit une m\'ethode automatique pour r\'esoudre ce probl\`eme, appellée \'enum\'eration. Nous d\'eclarons une \'enum\'eration de la mani\`ere suivante :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
	enum NomEnumeration
	{
		premierElement,
		deuxiemeElement,
		troisiemeElement
		...
	};
\end{lstlisting}\end{DDbox}

La num\'erotation\footnote{Ce n'est d'ailleurs pas forc\'ement 1, 2, 3, etc.} est automatique. En l'occurrence, notre enum\'eration s'\'ecrirait :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
	enum Size
	{
		Small,
		Medium,
		Big
	}
\end{lstlisting}\end{DDbox}

Le listing \ref{lst:besoinenum.cpp} devient alors :\\

\includecodecaption{besoinenumresolu.cpp}{Emploi d'une \'enum\'eration}

L'emploi d'une \'enum\'eration a donc r\'esolu nos probl\`emes :\\

\begin{itemize}

	\item Un mécanisme garantit que c'est bien une valeur valable qui sera passée en argument de la fonction f.
	\item Nous pouvons rajouter de nouvelles valeurs sans nous pr\'eoccuper de la
		num\'erotation.
	\item Le code obtenu est nettement plus lisible.
		
\end{itemize}

\section{Tableaux statiques}

Il est possible en C++ de d\'eclarer un \index{tableau}tableau de variables. Cela se fait de
la mani\`ere suivante :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=D\'eclaration d'un tableau]
Type arrayName[size];
\end{lstlisting}
\end{DDbox}

Par exemple,\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
double someArray[ 50 ];
\end{lstlisting}
\end{DDbox}

permet de d\'eclarer un tableau de 50 nombres réels en double pr\'ecision.\\

Nous acc\`edons alors aux \'el\'ements du tableau \`a l'aide de l'op\'erateur \texttt{[ ]}. Pour cr\'eer un tableau
de 10 \'el\'ements et y ranger les carr\'es des entiers de 1 \`a 10, nous \'ecririons:\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Utilisation d'un tableau]
double someArray[ 10 ];

for( int i = 0 ; i < 10 ; i++)
{
    someArray[i]=(i+1)*(i+1); //All arrays start at index 0
}
\end{lstlisting}
\end{DDbox}

La syntaxe \'equivalente en Python ou en VBA serait :
\begin{center}%
    \begin{minipage}{0.45\linewidth}
       \begin{center}\emph{Python}\end{center}
\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=python]
#c'est une liste et
#non un tableau
tableau = []

for i in range(1, 11):
	tableau.append(i * i)
\end{lstlisting}
\end{DDbox}
    \end{minipage}
    \qquad
    \begin{minipage}{0.45\linewidth}%
    \begin{center}\emph{VBA}\end{center}
\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=VBScript]
dim i as Integer
dim tableau(10) as Integer

for i=1 to 10
    tableau(i)=i*i
next i
\end{lstlisting}
\end{DDbox}
    \end{minipage}
\end{center}

Pour créer un tableau dont la taille n'est pas une constante écrite nommément dans le code, c'est beaucoup plus difficile; nous reviendrons sur ce point dans le chapitre \ref{chapter:memory}.\\

\section{Opérations de conversion / casting}

L'opération de convertir une variable d'un certain type en une variable d'un autre type s'appelle conversion de type, ou \textit{type casting}. Nous utiliserons indifféremment les deux dénominations.\\

\subsection{Conversions implicites}

Les conversions implicites, comme leur nom l'indique, ne requiert aucune opération de votre part et sont réalisées automatiquement par l'environnement. Ainsi le code suivant est correct : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="conversionImplicite", caption="Conversion implicite"]
float pi = 3.14;
double pii = pi;
\end{lstlisting}
\end{DDbox}

Il existe de nombreuses conversions implicites pour les types primitifs, comme les conversions suivantes : short => int, int => float, float=>double, double => int, etc.\\

\warning Il existe aussi des conversions implicites qui sont beaucoup moins évidentes. Ainsi, si le type \classname{B} possède un constructeur qui prenne en argument une instance de type \classname{A}, le cast implicite suivant est légal :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="conversionImplicite2", caption="Conversion implicite par le constructeur"]
class A {};
class B { public: B (A a) {} };

A a;
B b=a;
\end{lstlisting}
\end{DDbox}

C'est clairement une fonctionnalité WhatTheFuck du langage, mais elle reste assez agréable pour la déclaration de SmartPointer, cf chapitre \ref{chap:memory1}.\\

\subsection{Conversions explicites}

Pour de nombreuses autres conversions, il est nécéssaire d'expliciter l'opération de conversion. Cette explicitation se réalise en mettant à gauche de la variable que l'on souhaite convertir (caster) le type vers lequel nous souhaitons convertir, encadré par des parenthèses. Ainsi, la conversion suivante est-elle réalisée explicitement : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="conversionExplicite", caption="Conversion explicite d'un short en int"]
short s = 200;
int b = (int) s;
\end{lstlisting}
\end{DDbox}

Deux fonctions ou deux opérateurs peuvent avoir le même nom, mais posséder des arguments de type différents, et avoir ou non le même comportement. Ainsi, l'opérateur "/" (lire "divisé par") est-il défini différemment pour des entiers et pour des réels. Dans le cas où \varname{a} et \varname{b} sont des entiers, le résultat de \varname{a/b} est le quotient dans la division euclidienne de \varname{a} par \varname{b}. Ainsi, si \varname{a} vaut 16 et \varname{b} vaut 17, le résultat de \varname{a/b} vaut 0. Cependant, si \varname{c} et \varname{d} sont deux réels, alors le sens de \varname{c/d} correspond au quotient réel, qui vaut une valeur proche de 1, même si \varname{c} et \varname{d} ont pour valeur un entier.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="division", caption="Divisions réelles et euclidiennes"]
int a = 16;
int b = 17;
int q1 = a/b; //q1 = 0

double c = 16;
double d = 17;
double q2 = c/d // q2 = 0.94117647058
\end{lstlisting}
\end{DDbox}

Ainsi, lorsque nous voudrons estimer un quotient de deux entiers, il faudra bien prendre garde que sauf mention du contraire, le quotient calculé sera celui de la division euclidienne. Si nous voulons obtenir le quotient réel, il nous faut caster au moins un des deux arguments en réel, comme dans le listing suivant, afin de faire comprendre au compilateur que nous ne voulons pas du quotient euclidien.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="division2", caption="Cast d'un entier en double pour obtenir une division réelle"]
int a = 16;
int b = 17;
double q1 =((double) a)/b; //q = 0.94117647058
\end{lstlisting}
\end{DDbox}

\subsection{Indécisions sur les cast}

De manière semblable, définissons une fonction Power, qui prenne en argument deux réels \varname{x} et \varname{y} pour calculer $x^y$.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="power1", caption="Une première fonction Power"]
#include <math.h>
double Power(double x, double y)
{
    return exp(y*log(x));
}
\end{lstlisting}
\end{DDbox}

Nous pouvons donner en argument à cette fonction un entier, l'environnement se chargeant de réaliser le cast implicitement.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="power1bis", caption="Un autre cast implicite"]

void main()
{
    int a = 3;
    int b = 2;
    double c = Power(a,b);
}

\end{lstlisting}
\end{DDbox}

Définissons ensuite la même fonction Power dont les arguments sont cette fois-ci des \classname{float}.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="power2", caption="Une deuxième fonction Power"]
#include <math.h>
float Power(float x, float y)
{
    return exp(y*log(x));
}
\end{lstlisting}
\end{DDbox}

Nous ne pouvons plus maintenant réaliser de conversion implicite, car l'environnement ne sait s'il doit caster nos entiers en \classname{double} et utiliser la première fonction, ou bien caster nos entiers en \classname{float} et utiliser la deuxième fonction. Ainsi à la compilation, nous obtenons un message d'erreur semblable au suivant : \\

\begin{DDbox}{\linewidth}
more than one instance of overloaded function "Power" matches the argument list:
    function "Power(double x, double y)"
    function "Power(float x, float y)"
argument types are: (int, int)
\end{DDbox}

Il nous faut donc ici réaliser un cast explicite pour lever l'ambiguïté.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[language=C++,label="power2bis", caption="Le cast explicite est ici indispensable"]

void main()
{
    int a = 3;
    int b = 2;
    double c = Power( (double) a, (double) b);
}

\end{lstlisting}
\end{DDbox}

Bien que le C++ soit statiquement typé (cf paragraphe suivant) et que celà garantisse que de nombreuses erreurs de typage aient lieu à la compilation plutôt qu'à l'exécution (ce qui réduit très fortement leur potentiel de nuisance), il est possible de tromper le compilateur via toutes sortes d'horreurs résultant de casts explicites, et ainsi de passer les vérifications à la compilation et d'échouer seulement à l'exécution. Pour se prémunir au moins partiellement de ces problèmes, il existe différents opérateurs de cast supplémentaires (\functionname{dynamic\_cast<T>, static\_cast<T>, reinterpret\_cast<T>} et \functionname{const\_cast<T>}), mais ceci dépasse le cadre de notre cours.\\

\section{Le typage du C++}

Le C++ est un langage typ\'e de mani\`ere statique. Cela signifie que les variables doivent \^etre d\'eclar\'ees et leur types explicit\'es, à la différence par exemple du python où une même variable peut contenir successivement un entier puis une chaîne de caractère ou un double. Le compromis qui se cache derrière ce choix est un compromis souplesse / performance et garantie. Devoir déterminer à l'exécution le type d'une variable plutôt que de l'avoir déterminé statiquement a un certain coût. Les types n'existent en C++ qu'à la compilation, c'est à dire qu'à l'execution il n'est plus possible de récupérer le type d'un objet; cette limitation ne se retrouve pas dans des langages plus récents comme le C\#.\footnote{En C\#, on peut par exemple récupérer le type d'un objet à l'exécution, parcourir l'ensemble des types chargés en mémoire, sélectionner les types qui héritent de telle classe et qui possèdent un constructeur vide, les instancier, etc.}.
