
\begin{savequote}
\includegraphics[scale=0.4]{../../Pictures/PointersEverywhere.jpg}
\end{savequote}

\chapter{Les pointeurs}


\section{Définition des pointeurs}

Comme nous l'avons expliqué précédemment, le C++ permet à la fois de manipuler des abstractions puissantes mais aussi d'être très proche de la machine quand celà est nécessaire. Dans ce chapitre, nous nous plaçons à un niveau d'abstraction très bas pour présenter les pointeurs.\\

Chaque variable d'un programme est stockée dans une des mémoires de la machine qui exécute le code (mémoire Cache, mémoire RAM, disque dur, etc.). Nous pouvons pour le moment considérer la mémoire de notre machine comme un ensemble de cases mémoires contigües, chacune d'un octet. Chaque case est numérotée, afin de pouvoir rapidement accéder à une case précise. Lorsque nous écrivons :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
unsigned int n=3;
\end{lstlisting}\end{DDbox}

nous pouvons accéder de deux manières différentes à la valeur de notre variable : la première en faisant appel au nom de la variable, c'est à dire en invoquant son nom -n-, la deuxième en allant chercher directement en mémoire à l'adresse de notre variable la valeur qui s'y trouve. Dans le cas qui nous intéresse ici, la variable n a été stockée sur 4 octets, par exemple de cette manière :

\begin{center}
\begin{tabular}{l|l|l|l|l|l|l|l|l|l|l}
Case m\'emoire & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\hline
Nom &  &  &  & n  & n & n & n & &  & \\
\hline
Valeur &  &  &  & 110..000 & 00...  & 000...  & 000..  &  &  &   \\
\end{tabular}
\end{center}

Le C++ permet d'obtenir à l'exécution l'adresse d'une variable (qui va évidemment varier à chaque exécution puisque nous n'avons pas le contrôle sur l'endroit où nos variables sont stockées), grâce à l'opérateur \&. Il nous suffit donc d'écrire \&n pour obtenir l'adresse de n. Cette adresse correspond en fait à l'index de la première case mémoire dans laquelle est stockée notre variable (Dans notre exemple ce serait la case numéro 3). Naturellement, on pourrait penser que le type d'une adresse est donc un entier. En fait, il n'en est rien pour deux raisons :\\

\begin{itemize}
\item Il serait très facile de confondre un entier et son adresse si tous les deux étaient du même type.
\item Pour retrouver une variable en mémoire, il ne suffit pas de connaître l'adresse de la première case mémoire qui lui est allouée, il faut également connaître son type. En effet, si la variable stockée est un int ou un double, elle ne sera pas encodée de la même manière et ne prendra pas le même nombre de cases mémoires. \\
\end{itemize}

Pour avoir une correspondance parfaite entre une variable et son équivalent en mémoire, il nous faut donc connaître à la fois le type de la variable, et l'index de la première case mémoire où cette variable est contenue. Partant de cette remarque, nous pouvons construire un nouveau type de variable, appelé pointeur, qui va contenir les informations nécessaires pour retrouver en mémoire la valeur de notre variable n. Nous déclarons et définissons notre pointeur sur n par l'instruction suivante :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
int* pn= &n;
\end{lstlisting}\end{DDbox}

Dans l'instruction précédente, nous déclarons une variable pn de type pointeur sur entier (int*), et nous la définissons en lui affectant l'adresse de n, adresse récupérée par l'opérateur \&. Le symbole * est ici utilisé pour indiquer que pn n'est pas un entier mais un pointeur sur entier. Pour chaque type T "de base", nous avons donc un type correspondant qui est le type T*, et des variables de type T* que nous appelons pointeurs sur une instance de type T, ou, par abus de langage, simplement pointeur sur T.

\begin{habitudes}[Nom des pointeurs]
Prenez pour habitude de préfixer vos pointeurs par la lettre p, celà simplifie beaucoup la relecture du code.
\end{habitudes}

Nous pourrions de la même manière définir un pointeur sur double :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
double b = 3.2;
double* pb = &b;
\end{lstlisting}\end{DDbox}

\section{Déréférenciation}

Lorsque nous disposons d'un pointeur, nous pouvons souhaiter récupérer la valeur pointée, c'est à dire le \textit{déréférencer}. Pour celà, nous utilisons l'opérateur * --dit opérateur de déréférencement-- pour accéder à la valeur stockée à l'adresse du pointeur :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
double b = 3.2;
double* pb = &b;
double c = *pb;
\end{lstlisting}\end{DDbox}

\bigskip
\begin{warning}
Nous venons de voir deux utilisations distinctes du symbole * :
\begin{enumerate}
\item lors de la déclaration d'un pointeur, il spécifie que la variable pb par exemple est un pointeur sur double.
\item lors de la déréférenciation, c'est l'opérateur * qui associe à un pointeur la variable vers laquelle le pointeur renvoie.
\end{enumerate}
Il s'agit donc d'une homonymie de l'opérateur *, à laquelle il faut prendre garde lorsque l'on débute.
\end{warning}

\section{Opérateurs \& et *}

Les valeurs de a et de b sont égales à la suite des instructions suivantes :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
double a = 3.2;
double b = *(&a);
\end{lstlisting}\end{DDbox}

Les valeurs de pa et pb sont égales à la suite des instructions suivantes :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
double a = 3.2;
double* pa = &a;
double* pb = &(*pa);
\end{lstlisting}\end{DDbox}

Les instructions suivantes sont fausses car les types ne correspondent pas, et le compilateur retournera une erreur :\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
int a = 3;
double* pa = &a;
\end{lstlisting}\end{DDbox}

\subsection{Formalisation des pointeurs}

Notons E l'ensemble des variables stockées en mémoire d'un programme fini, et P l'ensemble des pointeurs qui pourraient être créés et qui pointeraient sur une de ces variables. On peut définir sur P une relation d'équivalence $\thicksim$ (réflexive, symétrique et transitive) par $px \thicksim py$ si et seulement si *px = *py. L'espace quotient de P par $\thicksim$ est en bijection avec E, et les opérateurs induits $\overline{*}$ et $\overline{\&}$ induits sont alors des bijections entre E et $\overline{P}$, inverses à gauche et à droite l'un de l'autre.

\section{Usage des pointeurs}

Les pointeurs sont omniprésents en C++. Des librairies comme la STL tendent cependant à diminuer leur utilisation directe par l'utilisateur, et aujourd'hui, il serait presque possible d'écrire en C++ sans utiliser de pointeurs. En effet, il est possible dans la plupart des cas d'écrire du code "plus haut niveau" où l'usage des pointeurs est caché. Néanmoins, il est fondamental que vous compreniez bien les mécaniques sous-jacentes. Les pointeurs restent souvent indispensables (de manière implicite ou explicite) pour le polymorphisme, lorsque nous manipulons des instances volumineuses, dans le cas de gestion dynamique de mémoire, dans la construction de la plupart des Design Pattern, ...\\

Les chapitres suivants montreront de nombreux exemples d'utilisation de pointeurs.

