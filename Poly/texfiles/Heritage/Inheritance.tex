\begin{savequote}[130mm]
In the fairy tales about heroes defeating evil villains there's always a dark
forest of some kind. It could be a cave, a forest, another planet, just some
place that everyone knows the hero shouldn't go. Of course, shortly after the
villain is introduced you find out, yes, the hero has to go to that stupid
forest to kill the bad guy. It seems the hero just keeps getting into
situations that require him to risk his life in this evil forest.\\

You rarely read fairy tales about the heroes who are smart enough to just avoid the whole situation entirely. You never hear a hero say, "Wait a
minute, if I leave to make my fortunes on the high seas leaving Buttercup behind I could die and then she'd have to marry some ugly prince named
Humperdink. Humperdink! I think I'll stay here and start a Farm Boy for Rent business." If he did that there'd be no fire swamp, dying, reanimation,
sword fights, giants, or any kind of story really. Because of this, the forest in these stories seems to exist like a black hole that drags the hero
in no matter what they do.\\

In object-oriented programming, Inheritance is the evil forest. Experienced programmers know to avoid this evil because they know that deep inside
the Dark Forest Inheritance is the Evil Queen Multiple Inheritance. She likes to eat software and programmers with her massive complexity teeth,
chewing on the flesh of the fallen. But the forest is so powerful and so tempting that nearly every programmer has to go into it, and try to make it
out alive with the Evil Queen's head before they can call themselves real programmers. You just can't resist the Inheritance Forest's pull, so you
go in. After the adventure you learn to just stay out of that stupid forest and bring an army if you are ever forced to go in again.\\
\qauthor{http://learnpythonthehardway.org/book/ex44.html}
\end{savequote}



\chapter{Héritage et Composition}
\label{chapter:inheritance}

\section{Héritage simple}

L'héritage est un des aspects fondamentaux de la programmation orientée-objet. Il permet de transmettre (\textit{de faire hériter})les propriétés d'une classe (méthodes et champs) à une autre classe, participant ainsi à la structuration des projets autour des classes.

\subsection{Motivation}

Par les vicissitudes d'une faille spatio-temporelle, vous vous retrouvez téléporté dans la peau d'un développeur pour une société de location de vélos et de voitures. Votre premier jet met en place les classes Bike et Car décrites dans les listings \ref{lst:Car1.h} et \ref{lst:Bike1.h}.\\

Pour ne pas perturber l'utilisateur des classes, ce sont les mêmes noms de variable qui sont utilisés dans les deux cas.\\

Nous faisons les remarques suivantes :
\begin{itemize}

	\item Les v\'elos et les voitures sont tous deux des v\'ehicules et
		partagent de nombreuses caract\'eristiques (prix, couleur,
		\'etat), mais ont cependant des diff\'erences.

	\item Si nous voulons ajouter un autre type de véhicule (des motos,
		par exemple), il va nous falloir recréer une nouvelle classe presque
		identique aux pr\'ec\'edentes.\\
\end{itemize}

\includecode{Car1.h}
\includecode{Bike1.h}


L'impression générale qui se dégage du code est une certaine lourdeur, liée aux redondances observées entre les classes Bike et Car. Dans la suite, nous cherchons à isoler ces redondances pour les factoriser et les écrire une seule fois.

\subsection{Héritage simple et public}

En informatique, cette factorisation est appelée \textit{héritage}, et consiste à isoler le code commun pour créer une classe avec les propriétés communes, que nous appellerons \textit{classe mère}. Les \textit{classes filles} ou \textit{classes dérivées}, dans notre exemple Car et Bike, vont hériter de cette classe mère et en possèderont toutes les propriétés.\\

\includecode{vehicule2.h}
\includecode{voiture2.h}
\includecode{velo2.h}

D'un point de vue syntaxique, la d\'eclaration d'une classe d\'eriv\'ee est donc
tr\`es simple. Il y a trois possibilit\'es :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
/*premiere possibilite*/
class Fille : public class Mere
{
    /*nouveaux membres*/
};
/*seconde possibilite*/
class Fille : protected class Mere
{
    /*nouveaux membres*/
};
/*troisieme possibilite*/
class Fille : private class Mere
{
    /*nouveaux membres*/
};

\end{lstlisting}
\end{DDbox}

Le lecteur attentif aura remarqu\'e l'emploi des mots public, protected, ou
private. Nous n'utilisons que la forme
\texttt{public} pour le moment et parlons alors d'héritage publique. Les autres types d'héritage sont brièvement abordés dans la section suivante.\\

La notion d'héritage présente les intérêts suivants :\\

\begin{enumerate}
\item Le code factorisé est plus court : les propriétés communes ne sont pas écrites plusieurs fois.
\item le code factorisé est plus lisible : la structure d'héritage participe à une meilleur compréhension du code. En particulier, elle indique les structures de dépendances ou de similarités entre classes.
\item Le code factorisé est plus extensible : il suffit d'ajouter ou de modifier un champ ou une méthode dans la classe mère pour en faire bénéficier toutes les classes filles.
\item Le code factorisé est plus maintenable : lorsque nous voulons modifier le code d'une méthode non factorisée mais dupliquée au sein de plusieurs classes, il faut la modifier dans chacune des classes de la même manière exactement et dans toutes ces classes, faute de quoi les méthodes qui étaient les mêmes commencent à différer. Lorsque le code est factorisé, il suffit de le modifier une seule fois.
\end{enumerate}

Nous pouvons appeler les m\'ethodes de la classe mère
\texttt{Vehicule} comme \varname{double GetPrice(void)} depuis un objet \texttt{Bike} ou \texttt{Car} comme si ces méthodes étaient implémentées dans les classes filles. Par exemple, le code-ci dessous fonctionnera correctement:\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
Bike b;

cout << b.GetPrice();
\end{lstlisting}
\end{DDbox}

\subsection{Le mot clef "protected"}

Lors de notre introduction \`a l'encapsulation, nous avions vu deux mots
cl\'es : \keyword{private} et \keyword{public}. \keyword{private} servait \`a
interdire au reste du monde d'acc\'eder \`a certains membres, et
\keyword{public} servait \`a autoriser le reste du monde \`a acc\'eder \`a
certains membres.\\

Que se passe-t-il si nous voulons dans une méthode fille accéder à un champ \keyword{private} de la classe mère ? Supposons par exemple que nous ajoutions une méthode \varname{void DisplayCost()} dans la classe Car, définie de la manière suivante : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void Car::DisplayCost(void)
{
    cout << "Cost of this car is : " << _price << " euros.\n"
}
\end{lstlisting}
\end{DDbox}

Si nous compilons le code pr\'esent\'e, le compilateur va nous donner une erreur :\\

\texttt{'\_price' : cannot access private member declared in class 'Vehicule'}\\

Que signifie cette erreur? Son origine est l'inaccessibilité/l'invisibilité de la variable \varname{\_price} dans les méthodes de la classe \varname{Car}. Nous avons en effet implicitement suppos\'e que nous avions acc\`es dans nos classes d\'eriv\'ees aux membres priv\'es de la classe m\`ere. Ce n'est pas le cas.\\

Dans le cadre de l'h\'eritage (publique) que nous traitons depuis le début, nous avons donc le comportement suivant :

\begin{itemize}
	\item Les membres \keyword{private} de la classe m\`ere ne sont \emph{pas} accessibles \`a la classe d\'eriv\'ee.
	\item Les membres \keyword{public} de la classe m\`ere sont accessibles \`a la classe d\'eriv\'ee.\\	
\end{itemize}

Nous ajoutons maintenant un niveau intermédiaire dans lequel les champs de la classe mère sont accessibles à la fois dans les méthodes de la classe mère et des classes filles, mais qui ne sont pas accessibles de l'extérieur de ces classes (comme par exemple dans le main). Le mot clef qui permet de définir ce niveau intermédiaire est le mot \keyword{protected}.\\

L'ensemble de ces r\`egles d'h\'eritage est r\'esum\'e dans le tableau \ref{tab:encapsulationvisibilite}.\\

\begin{table}
	\centering
	\begin{tabular}{l|l|l|l}
	Acc\`es	& public & protected & private\\
	\hline
	Membres de la classe & Oui & Oui & Oui \\
	\hline
	Membres des classes d\'eriv\'ees & Oui & Oui & Non\\
	\hline
	Reste du monde & Oui & Non & Non\\
	\hline
	\end{tabular}
	\caption{Encapsulation : diff\'erents degr\'es de visibilit\'e (cas de l'héritage publique)}
	\label{tab:encapsulationvisibilite}
\end{table}

Pour que nos classes d\'eriv\'ees aient acc\`es au membre \varname{\_price}, nous avons donc deux possibilit\'es :

\begin{itemize}
	\item  Utiliser l'accesseur \functionname{GetPrice};
	\item  Mettre \varname{\_price} en \keyword{protected}.
\end{itemize}

Nous allons retenir la seconde solution, et notre classe \classname{Vehicule} s'\'ecrira alors:\\

\includecode{vehicule3.h}

\subsection{Constructions et destructions d'objets filles}

Dotons-nous tout d'abord d'une classe mère avec deux constructeurs distincts, pour lesquels une sortie console est affichée à chaque appel, afin de savoir quand et quel constructeur a été appelé.\\

\includecode{Mother.h}
\includecode{Mother.cpp}

Nous créons alors une classe Child qui dérive publiquement de Mother.\\

\includecode{Child.h}
\includecode{Child.cpp}

Lorsque nous voulons construire un objet fille dans notre main, via par exemple le code suivant : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#include "Child.h"

void f()
{
    Child c;
}

void main()
{
    f();
}

\end{lstlisting}
\end{DDbox}

Nous pouvons lire après la fin de la fonction main dans la console les lignes suivantes : \\

\texttt{Default mother constructor called\\}
\texttt{Child empty constructor called\\}
\texttt{Child destructor called\\ }
\texttt{Mother destructor called\\ }

Nous observons ainsi que la construction d'un objet fille appelle implicitement un constructeur mère avant d'appeler le constructeur de la classe fille. De même, à la destruction de notre objet, le destructeur de la classe mère est appelé après le destructeur de la classe fille.\\

A la construction de notre objet fille, quel est le constructeur mère appelé ? Si nous ne le spécifions pas, c'est le constructeur mère par défaut qui est appelé, comme nous le voyons par le message de la console. Il est cependant possible d'expliciter quel constructeur de la classe mère nous voulons utiliser au début de la définition de notre constructeur fille. Ainsi, nous pouvons modifier de la sorte le constructeur fille pour que ce soit le constructeur mère avec 1 argument qui soit appelé :\\

\includecode{Child2.cpp}

\bigskip
\begin{warning}
Si vous ne spécifiez pas explicitement le constructeur mère à appeler lorsque vous construisez une fille, nous avons vu que c'était le constructeur mère par défaut qui était appelé. Dans un tel cas, et si le constructeur mère par défaut n'existe pas (par exemple si vous avez déclaré un seul constructeur dans Mother.h qui prend en argument des paramètres), alors votre IDE échouera à compiler, vous spécifiant un message de la sorte :\\

\texttt{Error C2512: 'Mother' : no default appropriate constructor available in child.cpp (l5)}

\end{warning}

\section{Autres héritages}

\subsection{Héritage protected et private}

Nous avions mentionn\'e dans la section précédente qu'il \'etait possible de
d\'eclarer une classe d\'eriv\'ee au moyen de trois mots cl\'es diff\'erents :
\keyword{private}, \keyword{protected}, et \keyword{public}. Jusqu'\`a
pr\'esent, nous n'avons employ\'e que le mot cl\'e \keyword{public}. Que
signifie-t-il pr\'ecis\'ement?\\

En réalité, chacun des mots clefs (public, private ou protected) agit comme une sorte de filtre sur la visibilit\'e des membres de la classe m\`ere. Pour ce point, la manière la plus claire de définir ces différents filtres est d'en donner un exemple :\\ 

\begin{DDbox}{\linewidth}
\begin{lstlisting}
class Mother
{
    public:
        int x;
    protected:
        int y;
    private:
        int z;
};

class Child1 : public Mother
{
    // x is public
    // y is protected
    // z is not accessible from Child1
};

class Child2 : protected Mother
{
    // x is protected
    // y is protected
    // z is not accessible from Child2
};

class Child3 : private Mother
{
    // x is private
    // y is private
    // z is not accessible from Child3
};
\end{lstlisting}
\end{DDbox}

\subsubsection{Quand utiliser de l'héritage protected ou private ?}

Il y a encore débat aujourd'hui, mais une réponse assez communément acceptée est : jamais. L'héritage protected ou private sert à pouvoir utiliser quelquechose sans en donner directement accès de l'extérieur. Il est en celà très proche de la composition, détaillée ci-dessous. Nous recommendons de passer plutôt par de la composition que par un héritage protected ou private. Pour trouver des exemples pertinents d'héritage private, nous renvoyons le lecteur par exemple à la programmation par "Policies" d'Alexandrescù \cite{Alexandrescu}, mais c'est un exemple qui excède largement notre propos.\\

\subsection{Héritage multiple et virtuel}


Nous avons vu dans la section pr\'ec\'edente que l'h\'eritage permet de
d\'ecrire une relation ``est un'' entre deux objets. Cependant, comment faire
dans le cas o\`u un objet ``est un'' X \emph{et} un Y ? L'h\'eritage multiple
permet de r\'esoudre ce probl\`eme. Avant de poursuivre, il nous semble important de
pr\'eciser que l'h\'eritage multiple est aussi \emph{dangereux\footnote{Il
est consid\'er\'e comme suffisamment dangereux pour \^etre explicitement
interdit dans les langages récents comme le JAVA ou le C\#. Le manque d'interface en C++ ne laisse maheureusement parfois pas d'autre choix que d'utiliser un héritage multiple. Nous ne saurions trop vous inciter néanmoins à l'utiliser avec la plus grande circonspection} que toxique}, pour
des raisons qui deviendront claires par la suite mais qui ont déjà été esquissées dans la citation de début de chapitre.

\subsubsection{Principe}

L'id\'ee est assez naturelle : nous allons faire h\'eriter notre classe
d\'eriv\'ee de \emph{deux} classes m\`eres. D'un point de vue syntaxique, on \'ecrira:

\begin{DDbox}{\linewidth}
\begin{lstlisting}
	class Child :
		public|protected|private class Mother1,
		public|protected|private class Mother2,
		. . .
		public|protected|private class MotherN
	{
	}		
\end{lstlisting}
\end{DDbox}

Par exemple, consid\'erons les classes de v\'ehicules pr\'ec\'edentes, et
ajoutons une nouvelle classe repr\'esentant un avion (ou tout autre objet
volant), qui va \'egalement d\'eriver de \classname{Vehicule}. Celui-ci aura
une nouvelle propri\'et\'e qui sera l'altitude maximum \`a laquelle le v\'ehicule peut voler.

\includecodecaption{avion4.h}{V\'ehicule volant}

Supposons \`a pr\'esent que nous souhaitions manipuler une voiture volante. Une telle voiture est \`a la fois un v\'ehicule volant et une voiture. Nous pouvons donc avoir recours \`a l'h\'eritage multiple et \'ecrire :

\includecode{voiturevolante.h}

Nous pouvons repr\'esenter l'ensemble des relations entre nos classes sur le
diagramme de la figure \ref{fig:heritageVehiculeVolant}.\\

\begin{figure}[]
	\begin{center}
		\includegraphics[scale=0.5]{../../Pictures/diamond}
	\end{center}
	\caption{H\'eritage multiple, le diamant}
	\label{fig:heritageVehiculeVolant}
\end{figure}

Comme aurait pu dire Vinz dans La Haine, "Jusqu'ici, tout va bien", et les choses nous paraissent assez naturelles. Cependant, nous pouvons
remarquer que \classname{FlyingCar} d\'erive de \classname{Car}  et
\classname{FlyingVehicle}, qui d\'erivent elles-m\^eme de la m\^eme classe de
base \classname{Vehicle}. Si nous regardons le dessin form\'e par les bo\^ites
d\'ecrivant les objets et les fl\`eches les reliant (figure
\ref{fig:heritageVehiculeVolant}), nous constatons que l'ensemble forme - au moins
approximativement - un losange, qui prend le nom de "Deadly Diamond of Death".\\

C'est l\`a que se trouve la difficult\'e principale de l'h\'eritage multiple,
que nous explicitons \`a pr\'esent.

\subsubsection{Deadly Diamond of Death}

Le probl\`eme est le suivant : le champ \varname{\_color} a
\'et\'e déclaré dans la classe \classname{Vehicle}, et il est donc hérité dans les classes \classname{FlyingCar} et
\classname{Car}. Supposons maintenant que nous ajoutions une m\'ethode \`a
\classname{FlyingCar} qui fasse appel à ce champ :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
void VehiculeVolant::DisplayColor()
{
	cout << "The color of our new brand flying car is " << \_color << ".\n";
}
\end{lstlisting}
\end{DDbox}

\`A la compilation, cette m\'ethode va provoquer une erreur. Pourquoi? Le
probl\`eme est que le champ \varname{\_color} qui a \'et\'e
d\'efini dans les classes m\`eres est h\'erit\'e \emph{deux fois} (une par l'héritage de \classname{Car} et une par l'héritage de \classname{FlyingVehicle}). L'appel
\`a ce champ dans \classname{FlyingCar} est donc ambigu. Le C++ nous fournit une technique permettant de lever cette ambigüit\'e, technique qui porte le nom d'\emph{h\'eritage virtuel}.

\subsubsection{H\'eritage virtuel}

La technique consiste simplement \`a pr\'eciser au compilateur qu'il ne doit
h\'eriter des champs et des méthodes de la classe \classname{Vehicle} qu'une seule fois,
et non deux. Cela se fait au moyen du mot cl\'e \keyword{virtual} que l'on
\'ecrira devant le nom de la classe dont on h\'erite :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
class child : public virtual Mother
{
}
\end{lstlisting}
\end{DDbox}

Les headers de nos classes \classname{FlyingVehicle} et \classname{Car} deviendront donc:\\

\includecodecaption{avion4.h}{vehiculeVolant4.h}
\includecode{voiture5.h}

\section{Composition}

dont déclaration forward.

\section{Héritage vs Composition}
