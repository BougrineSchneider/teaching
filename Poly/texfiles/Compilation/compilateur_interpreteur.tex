\chapter{Compilateurs, interpréteurs}
\bigskip

\textit{Note préliminaire : le terme compilation désigne originellement une étape du processus de transformation de votre code source en un programme exécutable. Par synecdoque, il est également utilisé pour décrire l'intégralité de ce processus. Dans la suite de ce chapitre, nous utiliserons le terme dans ses deux entendements.\\}

La compréhension théorique des différents concepts de la compilation revêt une importance pratique cruciale : c'est par cette compréhension que les étudiants peuvent résoudre les problèmes surgissant à la compilation ou à l'édition des liens, problèmes qui ne manqueront pas de surgir à la moindre tentative de compilation... Il faut donc relire ce chapitre jusqu'à l'avoir compris.\\

Qu'est ce que développer ? Développer ("écrire du code"), c'est projeter en pensée puis dans un langage de programmation un schéma d'exécution, une suite d'instructions (un "algorithme") qui réponde à l'objectif fixé.\\

Pour des raisons hardware, l'ordinateur ne comprend nativement qu'un jeu très faible d'instructions \footnote{en première approximation, car le nombre d'instructions disponibles dans les CPUs modernes est en train de devenir monstrueux.} (les opérations logiques OU, ET, NON, l'addition et la multiplication, etc...). Pour reprendre des éléments de comparaison avec les "vrais" langages, ce premier langage est trop peu expressif pour permettre de développer des programmes ambitieux. Au fur et à mesure que la puissance des ordinateurs s'est élevée \footnote{La loi de Moore, qui n'avait pas été énoncée en ces termes par Moore, stipule que la puissance des ordinateurs, c'est à dire leur fréquence (le rapport entre fréquence et puissance  des processeurs est détaillée dans la section \ref{chapter:hardware} ) double tous les 18 mois, et cette loi s'est remarquablement vérifiée jusque 2007/2008.}, il devenait possible de développer des programmes plus complexes, et la nécessité de créer des langages de développement plus riches, plus expressifs s'est alors fait ressentir. De nouveaux langages ont été développés, avec des règles qui leur sont propres.\\

Un langage informatique comporte un ensemble de règles qui peuvent être comparées aux "vrais" langages. De la même manière, il est composé d'une syntaxe, d'une grammaire, d'un vocabulaire, etc. Le langage informatique est un contrat passé entre le développeur et la machine, qui pose un cadre dans lequel tout code respectant les consignes du langage sera garanti de compiler et de pouvoir être exécuté.\\

Un programme est conçu comme un ensemble de fichiers textes comprenant la liste des instructions à exécuter. Cette liste peut être utilisée de deux manières : elle peut être transformée une fois pour toute en un exécutable, c'est à dire un ensemble d'instructions interprétables par la machine (on parle de \textit{compilation}), ou alors cette liste peut être lue au moment de l'exécution, et chaque instruction est transformée à la volée en un jeu d'instructions compréhensibles par la machine (on parle d'\textit{interprétation}). Même si tous les langages peuvent être interprétés et compilés, on a pour habitude de caractériser un langage par les implémentations qui en sont disponibles, c'est à dire s'il existe des compilateurs ou des interpréteurs pour ce langage. Les langages modernes peuvent donc abusivement se séparer en deux grandes catégories : les langages interprétés et les langages compilés \footnote{En réalité, les choses sont plus complexes, puisqu'il existe de nombreux langages semi-interprétés, que certains langages ne sont partiellement compilés qu'à l'exécution (c'est le cas pour C\# et Java avec la compilation Just In Time (JIT), que sont en développement des langages où la compilation se ferait en continu pendant l'exécution du programme (Compilation Continue), etc...}. Le C++ est un langage principalement compilé, mais il existe également des interpréteurs C++ \footnote{CINT, UnderC, ...}. Dans la suite de ce cours, nous considérons toujours une version compilée du C++.

\section{Déclaration/Définition}

En C++, il vous faut à la fois déclarer et définir vos variables, vos fonctions et vos classes. \\

La \textit{\textbf{déclaration}} d'une variable/fonction consiste en la mise en relation d'un nom et d'un type : par exemple, lorsque nous écrivons \varname{int x}, nous spécifions que la variable désignée par le nom "\varname{x}" sera de type entière. La \textit{\textbf{définition}} d'une variable/fonction consiste en l'affectation d'une valeur pour cette variable/fonction.\\

Dans le cas des variables, nous pouvons effectuer ces deux opérations en une seule ligne \footnote{en une seule ligne, mais pas de manière atomique. Ceci dépasse cependant le cadre de notre cours...} de la manière suivante :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
int x = 2;
\end{lstlisting}
\end{DDbox}

Nous pouvons également séparer en deux lignes différentes déclaration et définition, code dans l'exemple suivant :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
int x;
x = 2;
\end{lstlisting}
\end{DDbox}

\begin{habitudes}[Déclaration des variables]
Préférez, quand celà est possible, la première forme pour les déclarations/définitions de variables.
\end{habitudes}

Dans le cas des fonctions, la déclaration consiste en la donnée des informations suivantes : \textit{nom de la fonction}, \textit{scope de la fonction} (nous y reviendrons), \textit{type et nombre des arguments}, \textit{type de retour}, et éventuellement d'autres informations pour caractériser l'usage de la fonction (mots-clef static/extern etc...). Voici un exemple de déclaration de fonction :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
double Pow(double, int);
\end{lstlisting}
\end{DDbox}

Nous \textit{déclarons} ainsi une fonction Pow, qui prend deux arguments, l'un réel (type: double) et l'autre entier (type: int), et qui retourne un double.
Nous pouvons maintenant \textit{définir} cette fonction, c'est à dire instruire le compilateur de ce qu'elle fait exactement :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
double Pow(double x, int n)
{
    double result =1;
    for (int i = 0 ; i < n; i++)
    {
        result *= x;
    }
    return result;
}
\end{lstlisting}
\end{DDbox}

\textbf{Pour les fonctions, les déclarations sont remplies dans des fichiers spécifiques appelés fichiers headers et portant l'extension : ".h", alors que la définition de ces mêmes fonctions sera effectuée dans des fichiers appelés fichiers source portant l'extension ".cpp"} \footnote{Sauf dans le cas des fonctions inlinées ou templatées, mais nous y reviendrons.}.

\section{Les phases de la compilation}

La compilation de notre code source en un exécutable est composée de différentes phases. Pour la plupart des langages, il existe un logiciel ou une suite de logiciels appelés environnement de développement (IDE) qui implémente différentes fonctionalités nécessaires au développement : un éditeur de texte, un compilateur, un éditeur de liens, un débugger, un profiler, etc. Dans la plupart des IDE, vous posséderez un bouton "Compiler" qui s'acquittera des différentes étapes automatiquement. C'est le cas par exemple dans Visual Studio (raccourci par défaut F6 ou Ctrl+Shift+B). Cependant, il vous est nécessaire de comprendre les différentes étapes logiques de la compilation pour résoudre les problèmes rencontrés par votre IDE lors de cette compilation.

\section{Pré-compilation}

La précompilation (ou pré-processing) désigne l'ensemble des instructions réalisées par l'IDE au niveau du texte représentant le code source. Avant la précompilation, votre projet est un ensemble de fichiers textes, après la pré-compilation également. Les instructions de pré-processing commencent par le symbole \#. Parmi les instructions du pré-processeur, nous parlerons des \#include, des \#define, des \#ifndef, des \#endif et nous parlerons des macros uniquement pour vous les interdire.

\subsection{Les \#include}

Lorsque vous faites référence dans un fichier B à une fonction \underline{déclarée} dans un fichier A.h, il est nécessaire que le compilateur sache où trouver cette fonction. Le compilateur n'a pas besoin dans un premier temps d'en connaître la définition, mais il doit pouvoir accéder à sa déclaration : vous vous devez donc d'informer le compilateur qu'il pourra aller chercher des déclarations à l'intérieur du fichier A.h. Ceci se réalise grâce à la commande \#include qui sera insérée en en-tête du fichier B:\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#include "A.h"
\end{lstlisting}
\end{DDbox}

Au niveau de la précompilation, une opération est réalisée de telle sorte que le compilateur considère que le code du fichier A.h se trouve au début du fichier B, à l'endroit où se trouvait l'instruction \#include, ce qui va permettre au compilateur de pouvoir accéder dans B à la déclaration de la fonction déclarée dans A.h. Tout se passe donc "comme si" le contenu du fichier A.h était copié dans le fichier B. Cette étape est représentée dans la figure \ref{fig:preprocessing1}.\\

\begin{figure}
\includegraphics{../../graphes/Preprocessing.pdf}
\caption{Pendant l'étape de préprocessing, tout se passe comme si les déclarations contenues dans A.h étaient ajoutées en en-tête du fichier B.h}
\label{fig:preprocessing1}
\end{figure}

L'utilisation des guillemets spécifie au compilateur qu'il doit trouver le fichier A.h dans le répertoire courant de travail (c'est à dire le répertoire dans votre arborescence de fichier où se trouve votre projet). C'est en règle générale l'utilisation habituelle que vous en ferez. Cependant, lorsque vous utiliserez des fonctions définies non pas par vous mais dans le "noyau" du langage, vous utiliserez non plus des guillemets mais des $<>$ pour spécifier au compilateur qu'il doit aller chercher ce fichier dans les répertoires standards de votre IDE. Exemple :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#include <iostream>
\end{lstlisting}
\end{DDbox}

\subsection{Les \#define}

La commande \#define est initialement utilisée pour faire des substitutions de chaînes de caractères à l'intérieur du fichier dans lequel elle est écrite. Le pré-processeur va donc parcourir le fichier et remplacer toutes les occurences de la variable ainsi définie. Ainsi, la commande :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#define PI 3.141592653589793
\end{lstlisting}
\end{DDbox}

aura pour effet de remplacer partout dans le fichier où cette commande est définie la chaîne de caractères PI par la chaîne de caractères 3.141592653589793. Il faut vraiment comprendre cette opération comme de la substitution de texte.

\begin{habitudes}[Const et \#define]{Sauf raison spécifique, le lecteur est encouragé à préférer l'emploi de const (défini plus bas) plutôt que de recourir à des \#define. Comme le précise Scott Meyers dans \cite{EffCpp}, l'utilisation d'un \#define devient invisible dès la fin de l'étape de préprocessing, ce qui peut rendre plus complexe le débugging dans certains cas de compilation. De plus, une variable est générée pour chaque référence dans le code à un \#define, alors que l'utilisation d'un const ne génère la création que d'une seule variable.}
\end{habitudes}

\subsection{Les \#ifndef, \#endif}

Il est possible en C++ de faire de la compilation conditionnelle. C'est à dire qu'une partie de votre code source peut à votre demande n'être compilée que sous certaines conditions. La compilation conditionnelle repose sur la définition de variables de pré-processing, variables qui n'existent qu'avant l'étape de pré-processing. Voici un exemple de telles variables :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#ifndef PI
#define PI 3.141592653589793
#endif
\end{lstlisting}
\end{DDbox}

Grâce à ces variables\footnote{qui ne doivent pas être utilisées pour d'autres raisons d'ailleurs.}, nous allons pouvoir faire de la compilation conditionnelle, c'est à dire nous assurer qu'une partie de notre code ne sera compilée que si certaines conditions sont remplies. La compilation conditionnelle est principalement utilisée pour empêcher le compilateur de boucler à l'infini : reprenons notre exemple du fichier header B.h qui inclut le fichier A.h (via un include). Supposons maintenant que le fichier A.h inclut lui-même le fichier B.h. Que se passe-t-il par défaut ? Lorsque le pré-processeur lit l'instruction \#include "A.h" dans le fichier B.h, il inclut le contenu de A.h dans B.h, ce faisant, il lit le contenu qu'il insère et le pré-processe. Dans A.h, l'instruction \#include "B.h" est exécutée, et B.h est inclus dans A.h qui est inclus dans B.h, qui est inclus dans A.h, et ainsi de suite. Au bout d'un certain temps, votre compilateur rend l'âme et votre compilation échoue.\\

\begin{figure}
\includegraphics{../../graphes/Preprocessing2.pdf}
\caption{Exemple d'inter-dépendance de deux fichiers headers. Si rien n'est fait pour l'éviter, le compilateur va "boucler" à l'infini en ajoutant dans chaque header le contenu de l'autre.}
\label{fig:preprocessing2}
\end{figure}

Pour éviter ceci, nous allons donc recourir à la compilation conditionnelle; dans chaque fichier, nous adoptons un mécanisme qui s'assure que le code n'est inclus/compilé qu'une seule fois, même en cas d'inclusion multiple.\\

Le code du fichier A.h s'organise alors de la sorte:

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#ifndef A_H //Following code run only if
#define A_H //A_H is not already defined

/* Content of A.h */

#endif
\end{lstlisting}
\end{DDbox}

et le fichier B.h s'écrit de la même manière :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#ifndef B_H //Following code run only if
#define B_H //B_H is not already defined

/* Content of B.h */

#endif
\end{lstlisting}
\end{DDbox}

\begin{habitudes}[Compilation conditionnelle]
Tous les fichiers d'en-tête que vous créez doivent de la même manière contenir leur code entre les instructions \#ifndef et \#endif. \footnote{Il est possible de remplacer cette syntaxe par un \#pragma once, mais ceci n'est pas défini par la norme C++ : cette instruction est reconnue par Visual Studio mais pas par d'autres IDE, c'est pourquoi nous vous la déconseillons et n'en parlons pas plus avant.}.
\end{habitudes}

\subsection{Les macros}
\label{sec:macros}

Les macros sont des fonctions définies grâce à une instruction \#define. Elles permettent de définir des fonctions qui n'existeront plus à la compilation : tout comme les variables définies par un \#define sont remplacées avant la compilation par leur valeur, les fonctions définies par un \#define sont remplacées par la liste de leurs instructions. Un intérêt que nous pourrions trouver à cette technique est de supprimer l'appel à une fonction (parfois coûteux). Nous proposons à titre illustratif un exemple de macro.\\


\begin{DDbox}{\linewidth}
\begin{lstlisting}
#define MULTIPLICATE(x,y) x*y
\end{lstlisting}
\end{DDbox}

Partout où dans notre code un appel est fait à la macro MULTIPLICATE, le préprocesseur remplace l'appel à cet macro par le produit des deux arguments, sans appeler une fonction.\\

En réalité, les macros sont très dangereuses car particulièrement contre-intuitives. Puisqu'il ne s'agit pas d'appel à une fonction mais bien de substitution syntaxique du préprocesseur, elles génèrent souvent des comportements non attendus. L'utilisation de macros avait un sens il y a 20 ans, mais il n'en a plus aucun aujourd'hui\footnote{On leur préfère maintenant des fonctions templatées inlinées, qui ont les mêmes avantages, mais pas leurs inconvénients.}.
A titre d'exemple seulement, nous présentons trois cas simples dont les résultats, erronés, doivent vous dissuader d'utiliser des macros:\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#define MULTIPLICATE(x,y) x*y
\end{lstlisting}
\end{DDbox}

Appliquons la macro MULTIPLICATE en a+1 et b+1 :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
double y = MULTIPLICATE(a+1,b+1);
\end{lstlisting}
\end{DDbox}

Nous obtenons en expression littérale :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
y = a + 1*b + 1 = a + b + 1
\end{lstlisting}
\end{DDbox}

Ce qui est tout à fait différent du résultat anticipé. Ceci est dû au fait que l'étape de préprocessing est uniquement une étape de substitution syntaxique. Dans le cas présent, il manque des parenthèses à notre macro, que nous corrigeons alors par :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#define MULTIPLICATE(x,y) (x)*(y)
\end{lstlisting}
\end{DDbox}

Cette fois-ci, l'utilisation de la macro dans le cas précédent donne bien le résultat attendu. Cependant, dans le cas de l'expression suivante, la macro donne encore un résultat erroné :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
6 / MULTIPLICATE(2,3)
\end{lstlisting}
\end{DDbox}

Nous obtenons l'expression littérale :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
6 / 2 * 3 = 3 * 3 = 9
\end{lstlisting}
\end{DDbox}

Essayons alors la macro SQUARE :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
#define SQUARE(x) ((x)*(x))
\end{lstlisting}
\end{DDbox}


Nous vous laissons à titre d'exercice deviner pourquoi la variable y prend la valeur 6 dans le cas suivant :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}
int x = 1;
int y = SQUARE(x++);
\end{lstlisting}
\end{DDbox}

La conclusion de ce paragraphe est donc la suivante :\\

\begin{habitudes}[Utilisation des macros]
N'utilisez jamais de macros.
\end{habitudes}

\subsection{Templates}

C'est pendant l'étape de pré-processing que les classes et fonctions templatées sont créées. Selon l'usage des templates que vous aurez, cette phase pourra être réduite à sa plus simple expression ou au contraire se révéler très longue \footnote{Le lecteur intéressé par le pré-processeur découvrira avec joies les délices du méta-programming, ou de la compilation avec Boost...}. Nous reviendrons sur ce point dans le chapitre consacré aux templates.

\section{La compilation}

A la suite du pré-processing, vient la deuxième étape de la compilation dans laquelle le compilateur compile chaque fichier source (.cpp), c'est-à-dire qu'il transforme chacun de ces fichiers sources en fichiers binaires (.o ou .obj) contenant du code directement exécutable par la machine. Cette phase constitue la compilation proprement dite.

\begin{habitudes}[Compilation régulière]
Compilez votre code dès que possible. Quoi qu'il arrive, compilez au moins une fois par heure. Lorsque vous débutez, compilez toutes les 5 minutes. Si la compilation échoue, réglez les erreurs de compilation avant de continuer à développer. Si vous travaillez dans un IDE correct, il vous montrera les problèmes de code avant même que vous ne compiliez; réglez les dès que vous les voyez.\\

Dans un environnement professionnel, vous disposerez d'intégration continue via un serveur de build\footnote{Si ce n'est pas le cas, changez de société.}. Veillez à ne pas casser le build.
\end{habitudes}

\section{L'édition des liens}

Enfin, le linker (ou éditeur de liens en français) agrège chaque fichier .o ou .obj (avec éventuellement d'autres fichiers binaires si vous avez utilisé des librairies externes). Le linker va faire les liens entre les fichiers binaires générés en permettant de localiser le code correspondant aux appels de fonctions. Le linker vérifie en particulier que chaque fonction appelée dans le programme n'est pas seulement déclarée (ceci est fait lors de la compilation) mais aussi bien définie (chose qu'il n'avait pas vérifiée à ce stade). Il vérifie aussi qu'une fonction n'est pas implémentée dans plusieurs fichiers .o. A la fin de l'édition des liens, un exécutable est créé.

\section{Un exemple éléméntaire}

Nous disposons d'un projet contenant les fichiers main.cpp, A.cpp, B.cpp, A.h, B.h. Le fichier main.cpp fait référence au code contenu dans les fichiers A et B, le fichier A fait référence à B.\\

\begin{DDbox}{\linewidth}\begin{lstlisting}
///////////////////////////main.cpp//////////////////////
#include "A.h"
#include "B.h"

void main()
{
    functionInA();
    functionInB();
}

\end{lstlisting}
\end{DDbox}

\begin{DDbox}{\linewidth}\begin{lstlisting}
///////////////////////////A.h////////////////////////////

#ifndef A_H
#define A_H

#include "B.h" //not useful here, just put to illustrate the compilation process

void functionInA(void);

#endif
\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}\begin{lstlisting}
//////////////////////////B.h//////////////////////////////
#ifndef B_H
#define B_H

void functionInB(void);

#endif

\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}\begin{lstlisting}
////////////////////////////////////////////A.cpp///////////////////////////////////
#include "A.h"
#include "B.h"

void functionInA(void)
{
    functionInB();
}

\end{lstlisting}\end{DDbox}

\begin{DDbox}{\linewidth}\begin{lstlisting}
////////////////////////////////////////////B.cpp///////////////////////////////////
#include "B.h"

void functionInB(void)
{
    //Do Nothing
}

\end{lstlisting}\end{DDbox}

Le préprocesseur copie :

\begin{itemize}
\item les déclarations de B.h dans A.h,
\item les déclarations de A.h et B.h dans main.cpp,
\item les déclarations de A.h et B.h dans A.cpp,
\item les déclarations de B.h dans B.cpp
\end{itemize}

Le fait d'utiliser les \#ifndef \#endif nous permet d'éviter d'inclure deux fois les déclarations de B.h dans main.cpp et A.cpp, ce qui amènerait à des erreurs de compilation.\\

Une fois le preprocessing achevé, le compilateur convertit chaque fichier .cpp en un fichier binaire .o ou .obj (selon le compilateur). Lorsque les fichiers main.obj, A.obj et B.obj sont créés, l'éditeur des liens permet de matcher les fonctions, c'est à dire que l'éditeur des liens parcourt les fichiers .obj pour trouver la fonction functionInB() appelée dans la fonction functionInA(). Cette fonction est trouvée dans B.obj, et l'éditeur de lien indique que lorsque functionInA() appellera functionInB(), il faudra exécuter le code présent dans B.obj. L'éditeur de lien fait de même pour les fonctions functionInA() et functionInB() utilisées dans main.obj. Lorsque tous les appels à des méthodes extérieures sont résolus, l'éditeur de lien réassemble tous les fichiers .obj en un fichier exécutable (.exe) ou en une librairie (.dll).

\section{Survivre à des messages d'erreurs incompréhensibles}

\subsection{Erreurs à la génération du projet}

Lorsque vous voudrez compiler un projet, il y a fort à parier que la compilation échouera en raison d'erreurs. Votre IDE va vous fournir un descriptif d'une ou de plusieurs erreurs qu'il a rencontrées pendant la génération de votre projet. Même si ces erreurs sont multiples, seule la première des erreurs listées peut être considérée comme fiable, les autres erreurs étant sujettes à caution (en effet, un IDE est sensé fonctionner si vous fournissez un code sans erreur. Si vous lui demandez de compiler un code pour lequel il n'est pas sensé fonctionner, il est possible qu'il ne puisse pas identifier précisément tout ce qui l'empêche de fonctionner). \\

Tout débutant en informatique sait "coder", ce qui distingue un débutant autonome d'un débutant bloqué, c'est sa capacité à comprendre les messages sybillins d'erreurs de l'IDE. Dans un premier temps, il vous faudra comprendre si le premier message d'erreur retourné est un message du pré-processeur, du compilateur, ou de l'éditeur de lien. Dans le cas d'une erreur du compilateur, regardez le fichier et la ligne en cause : c'est probablement une erreur de syntaxe dans votre code, ou une utilisation d'une fonction  dont le compilateur ne trouve pas la déclaration en raison d'un \#include adéquat manquant en début de fichier. Dans le cas d'une erreur de l'éditeur des liens (ces erreurs commencent par LNK dans Visual Studio, pour "linker"), l'IDE a bien trouvé la déclaration de la méthode que vous utilisez, mais il n'a pas réussi à résoudre sa définition, c'est à dire qu'il a ou bien trouvé plusieurs fonctions de même nom et de même prototype et qu'il ne sait laquelle choisir, ou bien qu'il n'a trouvé aucune fonction qui convenait.\\

\begin{habitudes}[Environnement de travail en anglais]
Efforcez-vous d'avoir un IDE entièrement en anglais. Tout d'abord, puisque plus répandues, les versions anglophones des logiciels sont toujours moins buggées, ensuite parce que si vous avez un message d'erreur que vous n'arrivez pas à interpréter, une recherche dans google du message d'erreur en anglais vous mène souvent à une solution, alors que la même recherche sur le message d'erreur français vous apportera trop souvent : "Your search - ****** - did not match any documents."
\end{habitudes}

\subsection{Divide and Conquer}

Que vous ayez des problèmes à la compilation ou à l'exécution, si les messages d'erreur que vous obtenez ne sont pas suffisament explicites et que vous n'arrivez pas à diagnostiquer votre problème, adoptez une démarche dichotomique pour isoler la section de votre code fautive. Compilez/exécutez votre code en y enlevant certaines parties, et itérez ainsi afin de circonscrire la partie du code en défaut.

\subsection{Stack Overflow}

Une fois votre problème isolé, la résolution devrait vous paraître évidente. Dans le cas contraire, après vous être soigneusement assurés que vous ne pouviez trouver d'explications sur internet à votre problème isolé, vous pouvez le poster sur Stack Overflow (http://stackoverflow.com) avec un maximum d'explications et en veillant à bien respecter les règles de rédaction\footnote{http://stackoverflow.com/help/how-to-ask}.\\

Toutes les questions correctement formulées recoivent une réponse correctement formulée dans l'heure.









