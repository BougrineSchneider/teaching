\chapter{Allocation dynamique }

Dans ce chapitre, nous raffinons le modèle mémoire déjà ébauché en section \ref{sec:stack} en introduisant une nouvelle forme de mémoire, la \textit{Heap}, à la fois plus souple et plus complexe que la "\textit{Stack}".

\section{Motivation}

Comme nous l'avons vu dans la section \ref{sec:stack}, la zone mémoire dédiée à chaque fonction, la "\textit{Stack Frame}", est ajoutée à la \textit{Stack} lorsque nous entrons dans la fonction. De même, cette zone mémoire est automatiquement détruite lorsque nous terminons la fonction.\\

Il existe deux cas de figure dans lesquels nous ne pouvons/souhaitons pas utiliser la Stack pour stocker de la mémoire :\\

\begin{enumerate}
\item Lorsque nous souhaitons créer un objet dont le scope excède celui de la fonction dans laquelle il est créé. Si l'objet est stocké dans une Stack Frame, il sera détruit en même temps que celle-ci, il va donc falloir le stocker dans un autre espace pour le maintenir en vie plus longtemps.
\item Lorsque nous souhaitons créer un tableau dont la taille n'est pas connue à la compilation, voir même n'est pas connue à l'entrée de la fonction. Ce tableau ne peut donc être contenu dans une Stack Frame, puisqu'à la construction de cette Stack Frame, sa taille est encore inconnue.\\ 
\end{enumerate}

Ces deux exemples sont fondamentaux, et ils font l'objet de ce chapitre.

\section{Allocation dynamique : le cas des instances simples}

Mettons-nous tout d'abord dans la première situation, dans laquelle nous voulons créer des objets qui survivent à la fonction qui les crée, en les allouant sur la \textit{Heap}. Cette allocation s'effectue via l'opérateur \varname{new}. Considérons le code suivant : \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Exemple d' appel  \`a \texttt{new}]
class A
{
    public:
        A();
        ~A();
};

void f()
{
    A* pa = new A();
}

void main()
{
    int b = 3;
    f();
}

\end{lstlisting}
\end{DDbox}

Dans la fonction \functionname{f}, l'usage du mot clef \varname{new} nous permet d'instancier une variable de type A qui sera stockée dans la Heap et non pas sur la Stack. La création d'une instance de type A sur la Heap via le mot clef new retourne un pointeur de type A*, pointeur stocké dans la Stack Frame de \functionname{f}. Ce pointeur permet d'accéder à cette instance de type A nouvellement créée. Juste avant la sortie de la fonction f, notre mémoire est donc dans l'état du graphique \ref{fig:stack8}.\\

\begin{figure}[]
	\begin{center}
		\includegraphics[scale=0.5]{../../Pictures/stack8}
	\end{center}
	\caption{Etat de la Stack et de la Heap dans la fonction f, après l'allocation dynamique}
	\label{fig:stack8}
\end{figure}

Comme A est un type non primitif, la construction d'un A nécessite d'appeler un constructeur. Dans le cas présent, c'est le constructeur par défaut qui est appelé (en raison de l'absence d'argument). Si nous voulions procéder à l'instanciation d'un objet de type A via un autre constructeur, nous pourrions par exemple écrire le code du listing \ref{newWithSpecificConstructor}. \\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Exemple d' appel  \`a \texttt{new} en donnant un argument au constructeur-copie, label = newWithSpecificConstructor]
class A
{
    public:
        A(int i);
        ~A();
        void Display();
};

void f()
{
    int n = 8; 
    A* pa = new A(n);
}

void main()
{
    int b = 3;
    f();
}

\end{lstlisting}
\end{DDbox}

Des exemples non triviaux de cas où l'allocation dynamique est nécessaire sont donnés en fin de chapitre. 

\section{Les 3 problèmes de l'allocation dynamique de mémoire}

\subsection{Memory Leaks}
\label{sec:memoryLeak}

Nous savons \`a pr\'esent allouer de la m\'emoire selon nos besoins, en cours
d'ex\'ecution du programme. Qu'advient-il de cette m\'emoire allou\'ee  lorsque notre
code ne l'utilise plus? La r\'eponse est simple : elle reste allou\'ee. Pour
cela, nous devons détailler plus avant le processus d'allocation de la
m\'emoire.\\

L'OS (syst\`eme d'exploitation) d'un ordinateur
est un "programme" qui tourne en permanence, et qui se charge (entre autres) de
faire cohabiter les diff\'erents programmes tournant simultan\'ement les uns
avec les autres. En particulier, lui seul dispose d'un contr\^ole total sur la
m\'emoire de l'ordinateur. En pratique, chaque fois qu'un programme  demande de
la m\'emoire au moyen d'une instruction \texttt{new} ou similaire, c'est en
fait au syst\`eme d'exploitation qu'il la demande. Celui-ci r\'eserve alors une
zone, et la marque comme appartenant au programme demandant la m\'emoire.\\

Pendant l'ex\'ecution du programme, l'OS n'a \emph{aucune} raison de d\'esallouer la
m\'emoire qui a \'et\'e demand\'ee, et ce quelle que soit la situation. On
pourrait tr\`es bien imaginer des cas dans lesquels un utilisateur a lanc\'e
une trentaine de programme simultan\'ement qui consomment tous beaucoup de
m\'emoire, et o\`u l'OS aurait int\'er\^et, voire besoin de lib\'erer de la
m\'emoire. Cependant, il ne le fera jamais. Certains langages (Java, Python,
Pascal, etc.) fournissent un  m\'ecanisme de nettoyage automatique
\footnote{appel\'e Garbage-Collector, ou \textit{ramasse miette en Français}} de la mémoire qui n'est plus utilisée,
mais ce n'est pas le cas du C++ \footnote{Au moins à notre niveau}.\\

Afin d'\'eviter ce genre de situation, la mémoire allouée dans un programme doit \emph{toujours} être lib\'erée dès qu'elle n'est plus utilisée, faute de quoi elle encombrera la mémoire jusqu'à ce que le programme se termine ou meurt, un encombrement appelé \varname{Memory Leak} ou \varname{Fuite Mémoire}. \\

A la différence de la mémoire allouée sur la Stack qui est automatiquement libérée par l'environnement, la mémoire allouée sur la Heap doit donc être libérée manuellement et explicitement afin d'éviter ces Memory Leaks. Pour ce faire, nous notifions donc explicitement l'environnement lorsque nous souhaitons qu'il détruise une telle instance. Cette notification est réalisée au moyen de l'instruction \texttt{delete}. \texttt{delete} est un opérateur qui prend en argument un pointeur pointant sur une instance allouée sur la Heap, qui déréférence ce pointeur, détruit l'instance pointée en appelant le destructeur correspondant, puis libère la mémoire correspondante de la Heap. L'instruction prend donc la forme suivante :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Exemple d' appel  \`a \texttt{delete}]
void f()
{
    int n = 8;
    A* pa = new A(n);
    delete pa;
}
\end{lstlisting}
\end{DDbox}

Cet exemple est bien entendu idiot, puisque nous désallouons ici la mémoire dans la même fonction que nous l'allouons, ce qui supprime tout l'intérêt d'allouer dans la Heap plutôt que dans la Stack.\\

\begin{habitudes}[\texttt{new}/\texttt{delete}]
	
\`A chaque fois que nous écrions un \functionname{new}, il faut \'ecrire immédiatement le
\functionname{delete} associ\'e. Cela permet d'\^etre certain de ne pas
l'oublier, et donc d'\'eviter bien des probl\`emes plus tard.

\end{habitudes}

\subsection{Segmentation Fault}
\label{sec:segFault}

Lorsque nous appelons \functionname{delete} sur le pointeur \varname{pa}, l'instance pointée par pa est détruite, mais nous disposons toujours du pointeur, qui lui ne sera détruit que lorsque la Stack Frame dans lequel il est contenu sera détruite. Ainsi, par erreur, nous pourrions désallouer par deux fois une même zone mémoire de la Heap en appelant deux fois \functionname{delete} sur \varname{pa}.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Exemple d' appel  \`a \texttt{new}]
void f()
{
    int n = 8;
    A* pa = new A(n);
    delete pa;
    delete pa;
}
\end{lstlisting}
\end{DDbox}

Si nous exécutons ce code, nous obtenons une erreur au RunTime qui tue notre application, et affiche une fenêtre proche de celle affichée dans le graphe \ref{fig:segFault}.\\

\begin{figure}[]
	\begin{center}
		\includegraphics[scale=0.5]{../../Pictures/SegFault.jpg}
	\end{center}
	\caption{Screenshot d'une fenêtre d'erreur générée par une Segmentation Fault.}
	\label{fig:segFault}
\end{figure}

Les erreurs de Segmentation Fault sont particulièrement coûteuses, car elles sont complexes à répliquer et à isoler. Elles participent largement à faire du C++ un langage complexe et laborieux.\\

Donnons maintenant un cas classique où la Segmentation Fault apparaît naturellement. Nous construisons par composition un objet \varname{B} qui possède un objet \varname{A} construit dynamiquement dans le constructeur de \varname{B}. Pour lutter contre les problèmes de Memory Leak, il semble assez naturel d'assurer la libération de la mémoire de la Heap dans le destructeur de \varname{B}. En effet, puisque l'instance de type \varname{A} n'est pointée que par \varname{B}, elle devient superflue à la mort de \varname{B}, et peut donc être détruite dans le destructeur de \varname{B}. Ce design semble une excellente pratique, puisque nous n'avons plus à nous soucier de la libération de \varname{A} : c'est à la destruction automatique de \varname{B} que \functionname{delete} sera appelé et que le destructeur de \varname{A} sera appelé subséquemment et automatiquement.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Un cas classique de SegFault]
class A
{
public:
	A(void);
	~A(void);
};

class B
{
public:
	B(void);
	~B(void);

private:
	A* _pa;
};

B::B(void)
{
	_pa = new A();
}


B::~B(void)
{
	delete _pa;
}

\end{lstlisting}
\end{DDbox}

Cependant, si dans le code précédent nous passons par valeur l'instance de type \classname{B} en argument d'une fonction \functionname{f}, le constructeur-copie va recopier l'instance de type \classname{B} en une autre, et ces deux instances possèderont chacune un pointeur \varname{\_pa} possédant la même valeur, c'est à dire pointant sur le même objet de la Heap. Le code correspondant est décrit dans le listing \ref{SegFault} et l'état de la mémoire en entrant dans la fonction \functionname{f} est schémarisé dans le graphique \ref{fig:segFaultScheme}.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Un cas classique de SegFault, label=SegFault]

void f(B copy)
{

}

void main()
{
    B b;
    f(b);
}

\end{lstlisting}
\end{DDbox}

\begin{figure}[]
	\begin{center}
		\includegraphics[scale=0.5]{../../Pictures/SegFault.pdf}
	\end{center}
	\caption{b et copy possèdent chacun un pointeur qui référence l'instance de type A.}
	\label{fig:segFaultScheme}
\end{figure}

Lorsque la fonction \functionname{f} s'achève, sa Stack Frame est détruite, le destructeur de \varname{copy} est appelé automatiquement, celui-ci déréférence le pointeur \varname{\_pa} de \varname{copy} et désalloue l'instance pointée, c'est à dire l'instance de type \classname{A} présente sur la Heap. Lorsque la fonction \functionname{main} s'achève à son tour, l'instance \varname{b} est à son tour détruite automatiquement, son destructeur est appelé, et celui-ci tente d'appeler \functionname{delete} sur \varname{b.\_pa}, alors que l'instance de type \classname{A} a déjà été détruite, produisant ainsi une Segmentation Fault.\\

\subsection{Dangling Pointers}
\label{sec:dangling}

Enfin, le troisième risque que comporte la gestion dynamique de mémoire consiste à tenter de déréférencer un pointeur pointant vers une instance déjà détruite. Par exemple, le code du listing \ref{DanglingPointers} mène à un comportement indéfini à l'exécution.\\ 

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Exemple d' appel  \`a \texttt{new}, label=DanglingPointers]
void f()
{
    int n = 8;
    A* pa = new A(n);
    delete pa;
    
    pa->Display();
}
\end{lstlisting}
\end{DDbox}

\section{Smart Pointers}

Nous voudrions donc nous doter d'un pointeur "intelligent", appelé Smart Pointer dans ce qui suit, pour lequel nous avons le comportement d'un pointeur classique (possibilité de déréférencer le Smart Pointer via l'opérateur \texttt{*}, possibilité d'accéder aux champs et méthodes de l'instance pointée directement par l'opérateur \texttt{->}), mais pour lequel nous n'avons pas à gérer l'appel au \functionname{delete}, c'est à dire que ce Smart Pointer gère lui-même l'allocation et la désallocation dynamique de mémoire, sans créer de Memory Leaks ou de SegFault.\\ 

Nous commençons par écrire par écrire la partie "Wrapper" du Smart Pointer, c'est à dire les opérateurs \texttt{*} et \texttt{->}, comme dans le listing \ref{SmartPointer1} :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Première implémentation d'un SmartPointer, label=SmartPointer1]
template < typename T > class SmartPointer
{
    public:
        SmartPointer(T* pValue)
        {
            _pInner = pValue;
        }
        
        ~SmartPointer(){}

        T& operator* ()
        {
            return *_pInner;
        }

        T* operator-> ()
        {
            return _pInner;
        }

    private:
        T*    _pInner; // Generic pointer to be stored
};
\end{lstlisting}
\end{DDbox}

Dans cet exemple, nous retrouvons les problèmes de Memory Leaks détaillés dans la section \ref{sec:memoryLeak}. Nous pouvons donc ajouter un appel à l'opérateur \functionname{delete} dans le destructeur de notre Smart Pointer, comme il a été fait dans la section \ref{fig:segFault}, transformant ainsi notre code en celui du listing \ref{SmartPointer2}.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Seconde implémentation d'un SmartPointer, label=SmartPointer2]
template < typename T > class SmartPointer
{
    public:
        SmartPointer(T* pValue)
        {
            _pInner = pValue;
        }

        ~SmartPointer()
        {
            delete _pInner;
        }

        T& operator* ()
        {
            return *_pInner;
        }

        T* operator-> ()
        {
            return _pInner;
        }

    private:
        T*    _pInner; // Generic pointer to be stored
};
\end{lstlisting}
\end{DDbox}

Cependant, nous nous retrouvons avec les risques de Segmentation Fault expliqués dans la même section \ref{sec:segFault}. Pour régler cette difficulté, il nous faut remarquer que le problème de Segmentation Fault rencontré ici provient du fait que plusieurs Smart Pointers possèdent un pointeur vers le même objet dans la Heap, et que l'un de ces Smart Pointer supprime l'objet de la Heap alors que d'autres vont essayer de le faire plus tard. Il conviendrait donc de construire un mécanisme dans lequel c'est le dernier Smart Pointer qui pointe sur un objet et lui seul, qui va se charger de la désallocation. Pour réaliser ce mécanisme, nous allons donc construire un comptage du nombre de Smart Pointers "pointant" vers un objet de la Heap donné.\\ 

Dans les listings \ref{SmartPointer3} et \ref{SmartPointer4}, nous construisons une classe \classname{Count} qui va recenser le nombre de Smart Pointers pointant sur une instance donnée. A la construction, la construction-copie ou l'affectation via l'opérateur =, ce compte est incrémenté. A la destruction d'un Smart Pointer, ce compte est décrémenté. Lorsque le compte atteint 0 après une décrémentation dans le destructeur, plus aucun Smart Pointer ne pointe sur l'instance de la Heap, et nous pouvons alors nettoyer sans danger cette instance. Cette technique prend le nom de \textit{Reference Counting}.\\

Le Reference Counting s'inscrit dans un cadre plus large de gestion des ressources, et peut se résumer par un principe empirique de la "Rule of Three" : \textbf{si vous êtes amenés à expliciter pour une classe le code du destructeur, du constructeur-copie ou de la surcharge de l'opérateur =, alors probablement vous devriez expliciter le code pour chacune de ces 3 methodes.}.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Implémentation d'un SmartPointer avec un Reference Counting (Partie1), label=SmartPointer3]

template <typename T> class Counter
{
    public :
        
        void Decrement()
        {
            _count--;
        }
        
        void Increment()
        {
            _count++;
        }
        
        int GetValue()
        {
            return _count;
        }
        
        Counter()
        {
            _count = 1;
        }
        
    private :
        int _count;
}

\end{lstlisting}
\end{DDbox}

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Implémentation d'un SmartPointer avec un Reference Counting (Partie2), label=SmartPointer4]

template <typename T> class SmartPointer
{
    public:
        SmartPointer(T* pValue)
        {
            _pInner = pValue;
            _pCount = new Count();
        }

        ~SmartPointer()
        {
            _pCount->Decrement();
            if ( 0 == _pCount->GetValue())
            {
                delete _pInner;
                delete _pCount;
            }
        }
        
        SmartPointer(const SmartPointer<T>& spSource)
        {
            _pInner = spSource._pInner;
            _pCount = spSource._pCount;
            _pCount->Increment();
        }
        
        SmartPointer<T>& operator = (const SmartPointer<T>& spSource)
        {
            // Avoid self assignment
            if (this != &spSource) 
            {
                // Decrement the old reference count and remove old data if necessary
                _pCount->Decrement();
                if( 0 == _Count->GetValue())
                {
                    delete _pInner;
                    delete _pCount;
                }

                // Copy the data and counter then increment counter
                _pInner = spSource._pInner;
                _pCount = spSource._pCount;
                _pCount->Increment();
            }
            return *this;
        }
        
        T& operator* ()
        {
            return *_pInner;
        }

        T* operator-> ()
        {
            return _pInner;
        }

    private:
        T* _pInner;
        Count* _pCount;
};
\end{lstlisting}
\end{DDbox}

La différence entre le constructeur-copie et la surchage de l'opérateur = tient dans la possibilité d'écrire par erreur des choses semblables à celles du listing \ref{AequalsA}. Nous n'entrons pas plus dans le détail ici.\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[label=AequalsA]
a=a;
\end{lstlisting}
\end{DDbox}

Les propos développés dans cette section nous amènent à comprendre pourquoi la gestion de mémoire est difficile. Dans la vie réelle, la classe SmartPointer est déjà définie et disponible, il s'agit de la classe "\classname{shared\_ptr}" de la librairie standard, disponible via l'inclusion du header "<memory>". Nous invitons bien évidemment le lecteur à utiliser cette classe plutôt qu'à réimplémenter lui-même cette classe.\\

Il est important de noter que les algorithmes de Smart Pointers présentés dans cette section ne permettent pas de nettoyer parfaitement la mémoire. En effet, dans le cas de dépendances cycliques entre objets, ceux-ci ne pourront jamais être libérés via un mécanisme de Reference Counting.\\  

\section{Allocation dynamique : le cas des tableaux }
Supposons \`a pr\'esent que nous souhaitions \'ecrire un programme qui demande \`a l'utilisateur de rentrer un nombre $n$.
Le programme en question demande ensuite \`a l'utilisateur de rentrer $n$ nombres successifs, pour ensuite
tous les r\'eafficher.\\

\subsection{Allocation dynamique}
Spontan\'ement, nous voudrions cr\'eer un tableau de taille $n$ au moyen du code suivant : \\

\includecodecaption{tableautaillevariableerreur.cpp}{Tableau de taille variable}

Malheureusement, ce code est erronn\'e. En effet, comme nous l'avons vu
pr\'ec\'edemment, chaque fois que nous d\'eclarons une variable (ou un tableau),
l'environnement C++ r\'eserve des cases m\'emoires dans la Stack Frame correspondante. Mais pour les r\'eserver
correctement, il faut qu'il sache \emph{\`a la compilation}  combien de case il
doit r\'eserver, \emph{ce qui n'est pas le cas ici}. Il nous faut donc trouver une
autre solution.\\

Le probl\`eme se pose en ces termes : comment dire au compilateur " Je veux
r\'eserver n cases m\'emoires, \emph{pendant l'ex\'ecution et non pas à la compilation} du programme " ?\\ 

De la même manière que nous avons utilisé le mot clef \textbf{new} pour allouer dynamiquement une instance sur la Heap, nous pouvons utiliser ce même mot clef suivi d'un nombre entre crochets pour allouer dynamiquement un tableau d'un type donné à l'exécution. Dans le cas de la déclaration dynamique d'un tableau, l'instruction \textbf{new} renvoie un pointeur vers le début du tableau, c'est à dire vers son premier élement. La syntaxe (dans notre cas) est la suivante :\\

\begin{DDbox}{\linewidth}
\begin{lstlisting}[caption=Exemple d' appel  \`a \texttt{new}]
/*The following line allocates 10 integers onto the Heap*/
int* someArray = NULL;
someArray = new int [10];
\end{lstlisting}
\end{DDbox}

\subsection{Arithm\'etique des pointeurs}

Une fois la m\'emoire r\'eserv\'ee, nous voulons pouvoir acc\'eder au bloc
m\'emoire en question. Le langage C++ permet de traiter la zone m\'emoire ainsi
r\'eserv\'ee exactement comme un tableau standard. Par exemple, le code suivant
r\'ealise ce que nous voulions faire au d\'ebut (rentrer des nombres, les
stocker, et les r\'eafficher) :

\includecode{tableautaillevariable.cpp}

Cependant, que se passe-t-il en r\'ealit\'e? Lorsque l'on \'ecrit
\begin{lstlisting}
someArray[i]=30;
\end{lstlisting}

c'est en fait l'instruction suivante qui est ex\'ecut\'ee :
\begin{lstlisting}
*(someArray + i)=30;
\end{lstlisting}

En d'autre termes, someArray contient bien l'adresse du d\'ebut du bloc
m\'emoire. En ajoutant i, on se d\'eplace \footnote{Attention! Il y a ici une
subtilit\'e. Saurez-vous la voir?} \`a l'adresse du i-\`eme \'el\'ement, dont
on modifie la valeur \`a l'aide de l'op\'erateur de déréférentiation \texttt{*}. Le sch\'ema
ci-dessous repr\'esente la situation en m\'emoire lorsque l'on a un tableau de
taille 5 :

\begin{center}
\begin{tabular}{l|l|l|l|l|l|l|l|l|l|l}
Case m\'emoire & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\hline
Nom &  &  & someArray &  & \multicolumn{5}{c|}{m\'emoire r\'eserv\'ee pour le tableau} & \multicolumn{1}{l|}{} \\
\hline
Valeur &  &  & case mémoire 4 &  &  &  &  &  &  &  \\
\end{tabular}
\end{center}

Etudions le d\'eroulement du code suivant :
\begin{lstlisting}
int* tableau;

/*etape 1*/
tableau = new int [ 5 ];

/*etape 2*/
tableau[2] = 37;

/*etape 3*/
*(tableau + 2) = 42;
\end{lstlisting}

Apr\`es l'\'etape 1, nous sommes dans la situation ci-dessous :

\begin{center}
\begin{tabular}{l|l|l|l|l|l|l|l|l|l|l}
Case m\'emoire & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\hline
Nom &  &  & tableau &  & \multicolumn{5}{c|}{m\'emoire r\'eserv\'ee pour tableau} & \multicolumn{1}{l|}{} \\
\hline
Valeur &  &  & Case mémoire 4 &  &  &  &  &  &  &  \\
\end{tabular}
\end{center}

La m\'emoire r\'eserv\'ee n'est \emph{pas} initialis\'ee \`a 0 (ou tout autre valeur).

Apr\`es l'\'etape 2,
\begin{center}
\begin{tabular}{l|l|l|l|l|l|l|l|l|l|l}
Case m\'emoire & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\hline
Nom &  &  & someArray &  & \multicolumn{5}{c|}{m\'emoire r\'eserv\'ee pour tableau} & \multicolumn{1}{l|}{} \\
\hline
Valeur &  &  & Case mémoire 4 &  &  &  & 37  &  &  &  \\
\end{tabular}
\end{center}

le troisi\`eme \'el\'ement du tableau a \'et\'e modifi\'e.

Apr\`es l'\'etape 3,
\begin{center}
\begin{tabular}{l|l|l|l|l|l|l|l|l|l|l}
Case m\'emoire & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \\
\hline
Nom &  &  & someArray &  & \multicolumn{5}{c|}{m\'emoire r\'eserv\'ee pour tableau} & \multicolumn{1}{l|}{} \\
\hline
Valeur &  &  & Case mémoire 4 &  &  &  &  42 &  &  &  \\
\end{tabular}
\end{center}

le m\^eme \'el\'ement a \'et\'e modifi\'e, mais en \'ecrivant explicitement o\`u il se trouvait en m\'emoire.


Il est int\'eressant de remarquer que \texttt{*tableau = *(tableau + 0) =
tableau[0]} correspond au premier \'el\'ement du tableau. C'est une des raisons pour
lesquelles les tableaux en C++ commencent \`a l'indice 0 et non 1.\\


Une subtilit\'e s'est cependant gliss\'ee ici, qui a \'et\'e pass\'ee sous
silence pour des raisons de simplicit\'e. En effet, suivant son type, une
variable n'occupe pas le m\^eme nombre de cases m\'emoires : un \texttt{int} va
g\'en\'eralement\footnote{Le cas des \texttt{int} est un peu particulier,
puisqu'il d\'epend du type de processeur/compilateur utilis\'e. Sur les processeurs 32 bits,
ce sera 32 bits soit 4 octets (cases).} occuper 4 cases, un \texttt{char}
1 case, et un \texttt{double} 8 cases :

\begin{center}
\begin{tabular}{l|l|l|l|l|l|l|l|l|l|l|l|l|l}
Case m\'emoire & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\
\hline
Nom & \multicolumn{1}{c|}{char c} & \multicolumn{4}{c|}{int n} & \multicolumn{8}{c|}{double d} \\
\hline
Valeur &  &  &  &  &  &  &  &  &  &  &  &  &  \\
\end{tabular}
\end{center}

Pourquoi, lorsque l'on \'ecrit
\begin{lstlisting}
*(tableau + 2) = 42;
\end{lstlisting}

se trouve-t-on \`a l'adresse \texttt{tableau + 2* sizeof(int)\footnote{\functionname{sizeof} est une fonction particuli\`ere qui renvoie la taille en m\'emoire (le nombre de cases) d'une variable.}}  et non
\texttt{tableau + 2} (c'est à dire au milieu d'un entier)? Pour des raisons de confort,
lorsque l'on manipule des pointeurs, le compilateur C++ ajoute automatiquement le
\texttt{sizeof} n\'ecessaire. Cette arithm\'etique un peu particuli\`ere -on
ajoute 2 \emph{en apparence} - porte le nom d'arithm\'etique des pointeurs.

\section{Gestion de la mémoire pour les tableaux}

La création dynamique de tableaux souffre des mêmes difficultés que l'allocation dynamique de variable, difficultés recensées en sections \ref{sec:memoryLeak}, \ref{sec:segFault} et \ref{sec:dangling}. Afin de supprimer la mémoire, il faut recourir à l'opérateur \functionname{delete[]} qui permet de supprimer un tableau dynamique. Tout comme en section \ref{sec:memoryLeak}, ne pas appeler l'opérateur \functionname{delete[]}, c'est créer des Memory Leaks, et l'appeler deux fois c'est faire une Segmentation Fault.\\

Nous appuyant sur les considérations précédentes de ce chapitre et la Rule of Three, nous pouvons donc à présent construire une classe Vector, dont le constructeur prend en argument un entier n, construit un tableau dynamique de taille n, se comporte comme un tableau (i.e. possède un opérateur []), et évite à la fois les Memory Leaks et les SegFaults. Le code de cette classe Vector est présenté dans le chapitre suivant.\\

\section{Quelques pr\'ecautions}

Le langage C++ est un langage qui peut-\^etre consid\'er\'e comme de \emph{bas-niveau}
-par opposition \`a des langages comme Java, Python, Pascal, etc., qui
sont dits de haut niveau- dans la mesure o\`u il ne dissimule pas au
programmeur ce qui se passe dans l'ordinateur. Cela a des avantages (contr\^ole
tr\`es fin sur le d\'eroulement du programme, optimisations plus faciles \`a
effectuer pour le compilateur, meilleures performances \footnote{Ceci est de plus en plus discutable, cf les derniers benchmarks http://shootout.alioth.debian.org/; il faut de tout manière être très prudent lorsque l'on parle de performances}), et des inconv\'enients
(obligation de penser "comme la machine", plus grande difficult\'e \`a \'ecrire
du code robuste, augmentation du temps de d\'eveloppement)

Il est important de noter que plus de 50\% des bogues rencontr\'es lors du d\'eveloppement d'application sont dus \`a :
\begin{itemize}
\item des d\'epassements d'indices dans des tableaux
\item de la m\'emoire lib\'er\'ee plusieurs fois
\item des pointeurs non initialis\'es ou pointant sur des zones m\'emoires non-initialis\'ees.
\end{itemize}
Il convient donc, lorsque l'on \'ecrit du code manipulant de la m\'emoire, de le faire avec la plus grande prudence.\\

Récapitulatif :

\begin{itemize}
\item Un tableau est d\'eclar\'e en C++ de la mani\`ere suivante:
\begin{lstlisting}
typeDeVariable nomTableau[nbElements];
\end{lstlisting}
\item Si l'on a besoin d'un tableau de taille variable, ou inconnue \`a la compilation, il faut allouer dynamiquement de la m\'emoire, c'est-\`a-dire la demander
au syst\`eme au moyen de l'opérateur \functionname{new}. Celle-ci renvoie un pointeur sur une zone m\'emoire, qui peut \^etre manipul\'ee comme un tableau.
Par exemple,
\begin{lstlisting}
int* tableau = new int[40];
tableau[27] = 42;
\end{lstlisting}
\item Tout objet (tableau ou non) construit via l'opérateur new doit être détruit manuellement via l'opérateur delete (ou delete[] dans le cas d'un tableau). Cette destruction manuelle peut être déléguée dans un destructeur, mais il faut alors prendre garde aux constructeurs-copie et à la surcharge de l'opérateur =.
\end{itemize} 